<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git-study</title>
    <url>/2023/06/29/git-study/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="git的基本概念"><a href="#git的基本概念" class="headerlink" title="git的基本概念"></a>git的基本概念</h1><ul>
<li>工作区：仓库的目录。工作区是独立于各个分支的。</li>
<li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li>
<li>版本库：存放所有已经提交到本地仓库的代码版本。(存在一个<code>Head</code>指针指向当前版本树，代表现在所处的版本，将暂存区的内容提交到版本库时，会在<code>Head</code>指针后建立一个新的节点，代表新的版本，然后移动<code>Head</code>指针)</li>
<li>版本结构：树结构，树中每个节点代表一个代码版本。</li>
</ul>
<h1 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h1><ol>
<li><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在~/.gitconfig文件中</li>
<li><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在~/.gitconfig文件中</li>
<li><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中</li>
<li><code>git add XX</code>：将XX文件添加到暂存区</li>
<li><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</li>
<li><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉</li>
<li><code>git commit -m</code> “给自己看的备注信息”：将暂存区的内容提交到当前分支</li>
<li><code>git status</code>：查看仓库状态</li>
<li><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</li>
<li><code>git log</code>：查看当前分支的所有版本</li>
<li><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</li>
<li><code>git reset --hard HEAD^ 或 git reset --hard HEAD~</code>：将代码库回滚到上一个版本</li>
<li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li>
<li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li>
<li><code>git reset --hard 版本号</code>：回滚到某一特定版本</li>
<li><code>git checkout — XX或git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销</li>
<li><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</li>
<li><code>git push -u (第一次需要-u以后不需要</code>：将当前分支推送到远程仓库</li>
<li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li>
<li><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</li>
<li><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支</li>
<li><code>git branch</code>：查看所有分支和当前所处分支</li>
<li><code>git checkout branch_name</code>：切换到branch_name这个分支</li>
<li><code>git merge branch_name</code>：将分支branch_name合并到当前分支上</li>
<li><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</li>
<li><code>git branch branch_name</code>：创建新分支</li>
<li><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支</li>
<li><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支</li>
<li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</li>
<li><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</li>
<li><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</li>
<li><code>git checkout -t origin/branch_name</code>将远程的branch_name分支拉取到本地</li>
<li><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</li>
<li><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</li>
<li><code>git stash drop</code>：删除栈顶存储的修改</li>
<li><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</li>
<li><code>git stash list</code>：查看栈中所有元素</li>
</ol>
<h2 id="命令实战"><a href="#命令实战" class="headerlink" title="命令实战"></a>命令实战</h2><ol>
<li><p>通过<code>git init</code> 将当前目录配置成git仓库</p>
</li>
<li><p>编写一个文件<code>readme.txt</code>并写入内容<code>111</code></p>
</li>
<li><p>使用<code>git status</code> 查看当前仓库状态，在master分支存在文件没有添加任何要提交的内容，但存在未跟踪的文件（使用“git add”进行跟踪）。</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629205201067.png" alt="image-20230629205201067" style="zoom:50%;" /></p>
</li>
<li><p>使用<code>git add filename</code>对该文件进行追踪，即加入暂存区中。使用<code>git status</code>查看当前仓库状态：</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629205932637.png" alt="image-20230629205932637" style="zoom:50%;" /></p>
</li>
<li><p>使用<code>git commit</code>提交当前暂存区的内容到当前分支(<code>进行可持久化</code>)(<code>fitst commit</code>)</p>
</li>
</ol>
<p>​        <img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629210205398.png" alt="image-20230629210205398" style="zoom: 50%;" /></p>
<p>​        再次查看当前仓库的状态，发现暂存区已经清空</p>
<p>​        <img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629210241696.png" alt="image-20230629210241696" style="zoom:50%;" ></p>
<ol>
<li><p>对源文件进行修改后(<code>追加222</code>，再次提交进行持久化，观察各个步骤，仓库的状态。(<code>second commit</code>)</p>
<ul>
<li><p>修改<code>readme.txt</code>, 使用<code>git status</code>查看</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629212206964.png" alt="image-20230629212206964" style="zoom:50%;" /></p>
<p>出现两种操作:</p>
<ol>
<li><code>git add &lt;file&gt;</code> ：将修改提交到暂存区</li>
<li><code>gir restore &lt;file&gt;</code> ：对修改进行恢复，即<code>丢弃(discard)</code>这次对于工作区文件的修改。<ul>
<li>如果暂存区没有内容，工作区内容恢复到当前版本(HEAD指针指向的位置)。</li>
<li>如果有内容，恢复到暂存区的内容。</li>
</ul>
</li>
</ol>
</li>
<li><p>执行<code>git add</code>操作，查看工作区状态</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629213057698.png" alt="image-20230629213057698" style="zoom:50%;" /></p>
<p>拓展操作:</p>
<ol>
<li><code>git restore --staged &lt;file&gt;</code>：将<code>git add &lt;file&gt;</code>放在暂存区的内容恢复到当前<code>HEAD</code>指向的版本。</li>
<li><code>git diff &lt;file&gt;</code>：将当前版本的文件内容与暂存区的内容对比，如果暂存区为空，与当前<code>HEAD</code>指向的版本对比.</li>
</ol>
<p>​        <img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629214114827.png" alt="image-20230629214114827" style="zoom:50%;" /></p>
</li>
<li><p>再次进行修改，追加<code>333</code>，然后进行持久化操作。(<code>third commit</code>)</p>
<ol>
<li><p><code>git log --pretty=oneline</code>：查看从根节点到当前版本的版本树, 顺序自底向上，<code>HEAD</code>指向当前分支所在的版本</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629215008589.png" alt="image-20230629215008589" style="zoom:50%;" /></p>
</li>
<li><p><code>git reset --hard HEAD^</code> 或 <code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p>
<ul>
<li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li>
<li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li>
<li><code>git reset --hard 版本号1</code>：回滚到某一特定版本</li>
</ul>
</li>
<li><p><code>git reflog</code>：查看<code>HEAD</code>指针走过的所有版本。</p>
<p>跳到第二个版本，又跳回第三个版本</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629215946065.png" alt="image-20230629215946065" style="zoom:50%;" /></p>
</li>
</ol>
</li>
<li><p>新添加两个文件，<code>a.txt</code>, <code>b.txt</code>, 进行提交，作为第四个版本(<code>new add two txt</code>)</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629225325457.png" alt="image-20230629225325457" style="zoom:50%;" /></p>
<ol>
<li><p>对<code>a.txt</code>进行修改</p>
</li>
<li><p>提交到暂存区后，使用<code>git rm --cache a.txt</code> 取消对a.txt文件的追踪(<code>放弃对文件的管理</code>)，类似于工作区中刚创建该文件还没有add到暂存区），工作区没有任何变化。与<code>git restore --staged a.txt</code>的差别是：</p>
<ul>
<li>后者是使文件恢复到当前<code>HEAD</code>所指向的版本的文件内容，中间修改了文件，再次提交到暂存区内容不会发生变化。</li>
<li>前者是放弃对文件的追踪，可以通过<code>git add</code>恢复，不过如果中间修改了内容，再次提交到暂存区内容会发生变化。</li>
</ul>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629232535173.png" alt="image-20230629232535173" style="zoom:50%;" /></p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629234640637.png" alt="image-20230629234640637" style="zoom:50%;" /></p>
<p>版本：<code>rm a from cache</code></p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629234742060.png" alt="image-20230629234742060"></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<pre><code> ### 版本树

 ![image-20230629235130782](D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629235130782.png)
</code></pre><h2 id="推送到github"><a href="#推送到github" class="headerlink" title="推送到github"></a>推送到github</h2><ol>
<li><p>先在github创建一个与文件夹(yyyy)相同的仓库</p>
</li>
<li><p>执行<code>git remote add origin git@github.com:xxxxx/yyyy.git</code> 将本地的推送到远端</p>
</li>
<li><p><code>git clone git@github.com:xxxxx/yyyy.git</code>将远端的代码克隆到本地。</p>
</li>
<li><p><code>git checkout -b dev</code>创建并切换到dev分支</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630003101217.png" alt="image-20230630003101217" style="zoom:50%;" /></p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630003115697.png" alt="image-20230630003115697" style="zoom:50%;" /></p>
</li>
<li><p>修改readme.txt并持久化(<code>add 777</code>)</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630003153135.png" alt="image-20230630003153135" style="zoom:50%;" /></p>
</li>
<li><p>切换到<code>master</code>分支，将<code>dev</code>分支的内容合并到<code>master</code>分支</p>
</li>
</ol>
<p>​    <img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630003234807.png" alt="image-20230630003234807" style="zoom:50%;" /></p>
<ol>
<li>新建<code>dev</code>分支，修改readme.txt并持久化(<code>add 888</code>)</li>
</ol>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630004903874.png" alt="image-20230630004903874" style="zoom:50%;" /></p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005040229.png" alt="image-20230630005040229" style="zoom:50%;" /></p>
<ol>
<li><p>切换到<code>master</code>分支，修改readme.txt并持久化(<code>add 999</code>)</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005115395.png" alt="image-20230630005115395" style="zoom:50%;" /></p>
</li>
</ol>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005100804.png" alt="image-20230630005100804" style="zoom:50%;" /></p>
<ol>
<li>在<code>master</code>分支合并<code>dev</code>分支，出现冲突，处理完成后，在此进行持久化(<code>solve merge problem</code>)</li>
</ol>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005252849.png" alt="image-20230630005252849" style="zoom:50%;" /></p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005304312.png" alt="image-20230630005304312" style="zoom:50%;" /></p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005323661.png" alt="image-20230630005323661" style="zoom:50%;" /></p>
<p>查看版本树：</p>
<p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005402167.png" alt="image-20230630005402167" style="zoom:50%;" /></p>
<h3 id="版本树"><a href="#版本树" class="headerlink" title="版本树"></a>版本树</h3><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630011555500.png" alt="image-20230630011555500" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>DP基础</title>
    <url>/2023/07/14/DP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础1"><a href="#基础1" class="headerlink" title="基础1"></a>基础1</h1><p>类似于背包问题的状态转移方程<code>f[i][j]</code> 其中代表含义一般有两种:</p>
<ol>
<li>前<code>i</code>个物品，体积不超过<code>j</code>时的价值</li>
<li>前<code>i</code>个物品，体积恰好为<code>j</code>时的价值</li>
</ol>
<p><strong>使用第二种含义的一般情况：如果该问题的价值和<code>j</code>的取值相关，那么推荐使用第二种，比如：假设此时的最优解为 <code>f[3][3]</code> 。如果使用第一种定义，那么<code>f[3][4]</code>的结果会与<code>f[3][3]</code> 相同，但是因为价值需要使用体积<code>j</code>进行计算，会导致因为<code>j</code>的改变使最终结果不正确 (如果直接输出<code>f[n][m]</code>)，此时只有再枚举一遍(体积)才能得到最终结果，所以推荐使用第二种。</strong></p>
<p><strong><code>两种定义的初始化方程也不同，第一种：0，第二种：初始化为负无穷，f[0][0] = 0</code>。</strong></p>
<p><a href="https://www.acwing.com/problem/content/description/736/">能量石</a></p>
<ul>
<li><p>定义1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line">  ***</span><br><span class="line"></span><br><span class="line">- 定义<span class="number">2</span></span><br><span class="line"></span><br><span class="line">  ```c++</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://www.acwing.com/solution/content/83447/">题解参考</a></p>
<h1 id="基础2"><a href="#基础2" class="headerlink" title="基础2"></a>基础2</h1><p><strong>对于一般的<code>环形DP</code>问题，如何将环形问题转换成链式问题，将一个环所连接的数字进行2倍扩充后想连接，在此连接的基础上形成的序列，取原序列的长度就是每种环形肯出现的情况。</strong></p>
<h1 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h1><ol>
<li><p><a href="https://leetcode.cn/problems/edit-distance/description/">编辑距离</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(word1)</span><br><span class="line">        m = <span class="built_in">len</span>(word2)</span><br><span class="line"></span><br><span class="line">        f = [ [<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span> (n + <span class="number">1</span>) ]</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>] = <span class="built_in">list</span>(<span class="built_in">range</span>(m + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(word1):</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">0</span>] = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j, y <span class="keyword">in</span>  <span class="built_in">enumerate</span>(word2):</span><br><span class="line">                <span class="keyword">if</span> word1[i] == word2[j]:</span><br><span class="line">                    f[i + <span class="number">1</span>][j + <span class="number">1</span>] = f[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][j], f[i][j + <span class="number">1</span>], f[i][j]) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> f[n][m] </span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(word1)</span><br><span class="line">        m = <span class="built_in">len</span>(word2)</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> word1[i] == word2[j]:</span><br><span class="line">                <span class="keyword">return</span> dfs(i - <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(dfs(i - <span class="number">1</span>, j), dfs(i, j - <span class="number">1</span>), dfs(i - <span class="number">1</span>, j - <span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dfs(n - <span class="number">1</span>, m - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2023/07/02/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><h2 id="基础题型"><a href="#基础题型" class="headerlink" title="基础题型"></a>基础题型</h2><ol>
<li><a href="https://www.luogu.com.cn/problem/P1048">采药 </a><code>01背包简单应用</code></li>
<li><a href="https://www.luogu.com.cn/problem/U266184">宠物小精灵收服</a> <code>二维费用背包问题</code></li>
<li><a href="https://www.luogu.com.cn/problem/U291791">潜水员</a> <code>二维费用背包问题</code> <code>状态定义：是恰好满足</code> <code>重点：根据题意考虑初始化</code></li>
<li><a href="https://www.acwing.com/problem/content/280/">数字组合</a> <code>01背包</code> <code>状态定义: 恰好满足条件</code> <code>重点：根据题意考虑初始化</code></li>
</ol>
<h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><h2 id="基础题型-1"><a href="#基础题型-1" class="headerlink" title="基础题型"></a>基础题型</h2><ol>
<li><a href="https://www.luogu.com.cn/problem/U200694">庆功会</a> <code>多重背包</code> <code>滑动窗口优化</code></li>
</ol>
<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="基础题型-2"><a href="#基础题型-2" class="headerlink" title="基础题型"></a>基础题型</h2><ol>
<li><p><a href="https://www.luogu.com.cn/problem/T171705">买书</a> <code>完全背包</code> <code>基础题</code></p>
</li>
<li><p><a href="https://www.acwing.com/problem/content/902/">整数划分</a></p>
<ul>
<li><p>完全背包解法</p>
<p>题目可以理解成从<code>1~i</code>中选取任意数字，使它们的总和为<code>n</code>,求总共有多少种选法。类似于完全背包，每个物品的价值和体积都为<code>i</code>，总价值和体积为<code>n</code>。</p>
<ul>
<li><p>递归 + 记忆化搜索</p>
<p>dfs(i, c)：<code>1~i</code>个物品中，总和恰好为<code>c</code>的所有方案数</p>
<ul>
<li>当一个物品没有时，总和为0的方案数为1，其余为0</li>
<li>当第i个物品可以选择时，结果为 <code>dfs(i - 1, c) + dfs(i, c - i)</code> 即方案数和为不选择该数的方案数与选择该数的方案数的和。<strong>(因为可以重复选择，所以选择时的i不进行减一)</strong></li>
<li>当第i个物品不可以选择时，返回 <code>dfs(i - 1, c)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cache[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> c)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(cache[i][c] != <span class="number">-1</span>) <span class="keyword">return</span> cache[i][c]; </span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> c == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c &lt; i) <span class="keyword">return</span> <span class="built_in">dfs</span>(i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> ans = (<span class="built_in">dfs</span>(i - <span class="number">1</span>, c) + <span class="built_in">dfs</span>(i, c - i)) % mod;</span><br><span class="line">    cache[i][c] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cache, <span class="number">-1</span>, <span class="keyword">sizeof</span> cache);</span><br><span class="line">    std::cin&gt;&gt;n;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">dfs</span>(n, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code> - 递推

   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin&gt;&gt;n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">    std::cout &lt;&lt; f[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>计数DP</p>
<ul>
<li><code>f[i][j]</code> 代表总和为i时，选择j个数的方案数</li>
<li>根据当前方案最小值是否是1进行划分<ul>
<li>是1：方案数为<code>f[i - 1][j - 1]</code></li>
<li>不是1：方案数为<code>f[i - j][j]</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j] 代表总和为i时，选择j个数的方案数</span></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin&gt;&gt;n;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = (res + f[n][i]) % mod;</span><br><span class="line">    std::cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><h2 id="基础题型-3"><a href="#基础题型-3" class="headerlink" title="基础题型"></a>基础题型</h2><ol>
<li><a href="https://www.luogu.com.cn/problem/P1064">金明的预算方案</a> <code>多重背包</code> <code>如何进行正确分组且对于每个组别的体积和价值的计算</code></li>
</ol>
<h1 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h1><h2 id="基础题型-4"><a href="#基础题型-4" class="headerlink" title="基础题型"></a>基础题型</h2><ol>
<li><a href="https://www.acwing.com/problem/content/7/">混合背包模板题</a> <code>对完全背包，多重背包，01背包的混合使用</code></li>
</ol>
<h1 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h1><h2 id="基础题型-5"><a href="#基础题型-5" class="headerlink" title="基础题型"></a>基础题型</h2><ol>
<li><a href="https://www.acwing.com/problem/content/10/">有依赖的背包问题</a> <code>考虑树型结构</code></li>
</ol>
<h1 id="背包问题方案相关"><a href="#背包问题方案相关" class="headerlink" title="背包问题方案相关"></a>背包问题方案相关</h1><h2 id="基础题型-6"><a href="#基础题型-6" class="headerlink" title="基础题型"></a>基础题型</h2><ol>
<li><a href="https://www.acwing.com/problem/content/12/">背包问题求具体方案</a></li>
<li><a href="https://www.acwing.com/problem/content/11/">背包问题求方案数</a></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机问题</title>
    <url>/2023/07/14/%E7%8A%B6%E6%80%81%E6%9C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><h2 id="两个状态之间的转换"><a href="#两个状态之间的转换" class="headerlink" title="两个状态之间的转换"></a>两个状态之间的转换</h2><ol>
<li><p><a href="https://www.acwing.com/problem/content/1059/">股票买卖四</a> </p>
<p>存在两个状态能够进行转移：<code>1.手中有股票</code>，<code>2.手中无股票</code>。根据题意可得<code>1和2</code>都能自己进行转换，也能互相转换，但是<code>2要转换成1必须保证上一次交易完成，即手中没有股票</code>，所以需要设置三维的状态方程：<code>f[i][j][k]:</code>第i天完成j笔交易且状态为k时的价值，求最大值`</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">110</span>][<span class="number">2</span>], w[N]; <span class="comment">// f[i][j][k] 代表第i天完成j笔交易且状态为k时的价值，求最大值</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin&gt;&gt;w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j ++) &#123;</span><br><span class="line">            <span class="comment">// 1.前一天该交易就没有股票 2.前一天该交易有股票，进行交易</span></span><br><span class="line">            f[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>] + w[i]);</span><br><span class="line">            <span class="comment">// 2.前一天该交易有股票 2.前一天该交易就没有股票，今天交易完成后需要有股票，所以要确保昨天手中的股票已经卖出</span></span><br><span class="line">            <span class="comment">// 所以结果为前一天完成k-1笔交易时的价值减去买股票的价值</span></span><br><span class="line">            f[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - w[i]);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j ++) res = <span class="built_in">max</span>(res, f[n][j][<span class="number">0</span>]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><a href="https://www.luogu.com.cn/problem/U298750">股票买卖五</a></p>
<p><a href="https://www.acwing.com/solution/content/55147/">题解参考</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">3</span>]; </span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="comment">// f[0][1] = f[0][2] = -1e9;</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        f[i][<span class="number">1</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">0</span>] - w[i]);</span><br><span class="line">        f[i][<span class="number">2</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>] + w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[n][<span class="number">0</span>], f[n][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><a href="https://ac.nowcoder.com/acm/contest/63091/B">游游的01串操作</a></p>
<ul>
<li><p>状态机DP</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(s+<span class="number">1</span>);									</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">		f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>] + (s[i] - <span class="string">&#x27;0&#x27;</span>) * i;</span><br><span class="line">		f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + (<span class="string">&#x27;1&#x27;</span> - s[i]) * i;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">min</span>(f[len][<span class="number">0</span>], f[len][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模拟</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N], c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(c, s, <span class="keyword">sizeof</span> s);</span><br><span class="line">	<span class="type">int</span> ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 第一个不翻转</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; s[i]; i++) </span><br><span class="line">		<span class="keyword">if</span>(s[i] == s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">			s[i] = s[i] == <span class="string">&#x27;1&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">			ans1 += i;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 第一个翻转</span></span><br><span class="line">	ans2 ++;</span><br><span class="line">	c[<span class="number">1</span>] = c[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; c[i]; i++) </span><br><span class="line">		<span class="keyword">if</span>(c[i] == c[i - <span class="number">1</span>]) &#123;</span><br><span class="line">			c[i] = c[i] == <span class="string">&#x27;1&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">			ans2 += i;</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">min</span>(ans1, ans2) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法应用</title>
    <url>/2023/07/15/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><ol>
<li><p><a href="https://www.acwing.com/problem/content/description/832/">单调栈</a></p>
<p><code>快速求一个数列左边第一个比它小的数，可进行拓展</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sa[N];</span><br><span class="line"><span class="type">int</span> tt, n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; sa[tt] &gt;= x) tt --;</span><br><span class="line">        <span class="keyword">if</span> (tt) cout &lt;&lt; sa[tt] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        sa[++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><ol>
<li><p><a href="https://www.acwing.com/problem/content/156/">滑动窗口</a></p>
<p><code>快速求给定范围一段区间内的最值</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//q[N]存储的是下标，时刻保持队列头为要找的结果，如果达到长度就将队列头移出，否则时刻更新队列头的状态</span></span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k &gt;= q[hh]) hh ++; <span class="comment">// 超过距离，退出</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) tt --;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt --;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><ol>
<li><p><a href="https://www.acwing.com/problem/content/833/">kmp字符串匹配</a></p>
<p><a href="https://www.acwing.com/solution/content/14666/">提解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>, M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N];  <span class="comment">// next[i] 以i为结尾的p的子串，前缀与后缀相匹配的子串的长度最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++;</span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><a href="https://www.acwing.com/problem/content/description/143/">周期</a></strong></p>
<p><a href="https://www.acwing.com/solution/content/4614/">题解</a></p>
</li>
<li><p><strong><a href="https://www.acwing.com/problem/content/description/161/">奶牛矩阵</a></strong>  <code>本题是处理字符串的匹配</code></p>
</li>
<li><p><strong><a href="https://www.acwing.com/problem/content/description/162/">匹配统计 </a></strong><code>字符串hash</code></p>
</li>
</ol>
<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><ol>
<li><p><a href="https://www.acwing.com/problem/content/837/">Trie字符串统计</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> n, idx, cnt[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> ch[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>; <span class="comment">// 代表等级</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; ch[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = ch[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx; </span><br><span class="line">        p = son[p][u]; </span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> ch[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; ch[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = ch[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) cout &lt;&lt; <span class="built_in">query</span>(str) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p><a href="https://www.acwing.com/problem/content/5138/">奶牛用餐</a></p>
<p><strong>当有空余座位时，可以随意选择空余的座位，当没有时，需要等待最小完成的座位，所以使用优先队列存储所有的座位完成的时间，每次取出最小完成的座位的最后时间与目前要安排的奶牛的时间进行比较，选择较大的时间，并与时间间隔相加，计算最后完成的时间加入优先队列中</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt;&gt; heap;</span><br><span class="line"><span class="comment">// 当有空余座位时，可以随意选择空余的座位，当没有时，需要等待最小完成的座位，所以使用优先队列存储所有的座位完成的时间</span></span><br><span class="line"><span class="comment">// 每次取出最小完成的座位的最后时间与目前要安排的奶牛的时间进行比较，选择较大的时间，并与时间间隔相加，计算最后完成的时间</span></span><br><span class="line"><span class="comment">// 加入优先队列中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) heap.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        ll st,ti;</span><br><span class="line">        cin&gt;&gt;st&gt;&gt;ti;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        ll ed = <span class="built_in">max</span>(st, t) + ti;</span><br><span class="line">        heap.<span class="built_in">push</span>(ed);</span><br><span class="line">        cout &lt;&lt; ed &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java8</title>
    <url>/2023/07/16/java8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>区间DP</title>
    <url>/2023/07/18/%E5%8C%BA%E9%97%B4DP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础题型"><a href="#基础题型" class="headerlink" title="基础题型"></a>基础题型</h1><ol>
<li><a href="https://www.acwing.com/problem/content/284/">石子合并</a> <code>区间DP</code></li>
<li><a href="https://www.luogu.com.cn/problem/P1880">环形石子合并 </a> <code>区间DP</code></li>
<li><a href="https://www.luogu.com.cn/problem/T156025">凸多边形的划分</a>  <code>区间DP</code>  <code>高精度</code></li>
<li><a href="https://www.acwing.com/problem/content/481/">加分二叉树</a> <code>区间DP</code>  <code>查询方案内容</code></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP</title>
    <url>/2023/07/19/%E6%A0%91%E5%BD%A2DP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础题型"><a href="#基础题型" class="headerlink" title="基础题型"></a>基础题型</h1><ol>
<li><a href="https://www.acwing.com/problem/content/1074/">树的最长路径</a></li>
<li><a href="https://www.acwing.com/problem/content/1075/">树的中心</a></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>nowcoder-week</title>
    <url>/2023/08/07/nowcoder-week/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="牛客周赛-Round-6-2023-08-06"><a href="#牛客周赛-Round-6-2023-08-06" class="headerlink" title="牛客周赛 Round 6 2023-08-06"></a>牛客周赛 Round 6 2023-08-06</h1><p><a href="https://ac.nowcoder.com/acm/contest/62622">题目地址</a></p>
<ol>
<li><p>游游的数字圈 <code>简单模拟</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s; <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ans+=a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>竖式乘法 <code>简单模拟</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll s[N]; <span class="type">int</span> t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">while</span>(b) &#123;</span><br><span class="line">            <span class="type">int</span> x = b % <span class="number">10</span>;</span><br><span class="line">            ans+= a*x;</span><br><span class="line">            b /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>游游的数值距离</p>
<p>根据题目进行枚举<code>x</code>，然后化简求最小值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> ans = n;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">2</span>, a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">12</span>; i ++)&#123; <span class="comment">// x 从3开始枚举</span></span><br><span class="line">		x *= i;</span><br><span class="line">		<span class="type">int</span> t = x - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> k = n / t; <span class="comment">// y</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(t * k - n) &lt; ans &amp;&amp; k != <span class="number">2</span>)&#123;</span><br><span class="line">			ans = <span class="built_in">abs</span>(t * k - n);</span><br><span class="line">			a = i;</span><br><span class="line">			b = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(t * (k + <span class="number">1</span>) - n) &lt; ans &amp;&amp; k + <span class="number">1</span> != <span class="number">2</span>)&#123;</span><br><span class="line">			ans = <span class="built_in">abs</span>(t * (k + <span class="number">1</span>) - n);</span><br><span class="line">			a = i;</span><br><span class="line">			b = k + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>游游的k-好数组 <code>模拟</code> <code>重点</code></p>
<p>由题目可以推出 {a~0~, a~1~, a~2~,  a~3~ , a~4~, …., a~k-1~} 的和与  {a~1~, a~2~,  a~3~ , a~4~, …., a~k~} 的和相同即  <strong>a~0~ == a~k+1~</strong> ,所以创造k个数组将数组按照下标符合 <strong>i % k</strong> 的进行分组，其中每个分组中每个数据与最大值的差的和就是需要进操作的次数，最后为了求最大值，将最后剩余的次数分配到每个分组中，寻找最大值即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll x;</span><br><span class="line">ll a[N], last[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;</span><br><span class="line">        vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">V</span>(k); <span class="comment">// 分成k组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) V[i % k].<span class="built_in">push_back</span>(a[i]); <span class="comment">// 按照下标分组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ll mv = V[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; V[i].<span class="built_in">size</span>(); j++) mv = <span class="built_in">max</span>(mv, V[i][j]);</span><br><span class="line">            last[i] = mv;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; V[i].<span class="built_in">size</span>(); j++) x -= (mv -V[i][j]); <span class="comment">// 每组需要的操作数</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ll ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">                <span class="comment">// 将剩下的操作数给每个分组分配，并求最大值</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, last[i] + x / (ll)V[i].<span class="built_in">size</span>());</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>小红的循环节长度</li>
</ol>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>牛客周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>linux</title>
    <url>/2023/08/09/linux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">功能：</span><br><span class="line">    (1) 分屏。</span><br><span class="line">    (2) 允许断开Terminal连接后，继续运行进程。</span><br><span class="line">结构：</span><br><span class="line">    一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。</span><br><span class="line">    实例：</span><br><span class="line">        tmux:</span><br><span class="line">            session 0:</span><br><span class="line">                window 0:</span><br><span class="line">                    pane 0</span><br><span class="line">                    pane 1</span><br><span class="line">                    pane 2</span><br><span class="line">                    ...</span><br><span class="line">                window 1</span><br><span class="line">                window 2</span><br><span class="line">                ...</span><br><span class="line">            session 1</span><br><span class="line">            session 2</span><br><span class="line">            ...</span><br><span class="line">操作：</span><br><span class="line">    (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</span><br><span class="line">    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。</span><br><span class="line">    (3) 按下Ctrl + a后手指松开，然后按&quot;（注意是双引号&quot;）：将当前pane上下平分成两个pane。</span><br><span class="line">    (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</span><br><span class="line">    (5) 鼠标点击可以选pane。</span><br><span class="line">    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。</span><br><span class="line">    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。</span><br><span class="line">    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。</span><br><span class="line">    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。</span><br><span class="line">    (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。</span><br><span class="line">    (11) tmux a：打开之前挂起的session。</span><br><span class="line">    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。</span><br><span class="line">        方向键 —— 上：选择上一项 session/window/pane</span><br><span class="line">        方向键 —— 下：选择下一项 session/window/pane</span><br><span class="line">        方向键 —— 右：展开当前项 session/window</span><br><span class="line">        方向键 —— 左：闭合当前项 session/window</span><br><span class="line">    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。</span><br><span class="line">    (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。</span><br><span class="line">    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。</span><br><span class="line">    (16) 鼠标滚轮：翻阅当前pane内的内容。</span><br><span class="line">    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</span><br><span class="line">    (18) tmux中复制/粘贴文本的通用方式：</span><br><span class="line">        (1) 按下Ctrl + a后松开手指，然后按[</span><br><span class="line">        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</span><br><span class="line">        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</span><br></pre></td></tr></table></figure>
<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">功能：</span><br><span class="line">    (1) 命令行模式下的文本编辑器。</span><br><span class="line">    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</span><br><span class="line">    (3) 使用方式：vim filename</span><br><span class="line">        如果已有该文件，则打开它。</span><br><span class="line">        如果没有该文件，则打开个一个新的文件，并命名为filename</span><br><span class="line">模式：</span><br><span class="line">    (1) 一般命令模式</span><br><span class="line">        默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</span><br><span class="line">    (2) 编辑模式</span><br><span class="line">        在一般命令模式里按下i，会进入编辑模式。</span><br><span class="line">        按下ESC会退出编辑模式，返回到一般命令模式。</span><br><span class="line">    (3) 命令行模式</span><br><span class="line">        在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。</span><br><span class="line">        可以查找、替换、保存、退出、配置编辑器等。</span><br><span class="line">操作：</span><br><span class="line">    (1) i：进入编辑模式</span><br><span class="line">    (2) ESC：进入一般命令模式</span><br><span class="line">    (3) h 或 左箭头键：光标向左移动一个字符</span><br><span class="line">    (4) j 或 向下箭头：光标向下移动一个字符</span><br><span class="line">    (5) k 或 向上箭头：光标向上移动一个字符</span><br><span class="line">    (6) l 或 向右箭头：光标向右移动一个字符</span><br><span class="line">    (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</span><br><span class="line">    (8) 0 或 功能键[Home]：光标移动到本行开头</span><br><span class="line">    (9) $ 或 功能键[End]：光标移动到本行末尾</span><br><span class="line">    (10) G：光标移动到最后一行</span><br><span class="line">    (11) :n 或 nG：n为数字，光标移动到第n行</span><br><span class="line">    (12) gg：光标移动到第一行，相当于1G</span><br><span class="line">    (13) n&lt;Enter&gt;：n为数字，光标向下移动n行</span><br><span class="line">    (14) /word：向光标之下寻找第一个值为word的字符串。</span><br><span class="line">    (15) ?word：向光标之上寻找第一个值为word的字符串。</span><br><span class="line">    (16) n：重复前一个查找操作</span><br><span class="line">    (17) N：反向重复前一个查找操作</span><br><span class="line">    (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</span><br><span class="line">    (19) :1,$s/word1/word2/g：将全文的word1替换为word2</span><br><span class="line">    (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。</span><br><span class="line">    (21) v：选中文本</span><br><span class="line">    (22) d：删除选中的文本</span><br><span class="line">    (23) dd: 删除当前行</span><br><span class="line">    (24) y：复制选中的文本</span><br><span class="line">    (25) yy: 复制当前行</span><br><span class="line">    (26) p: 将复制的数据在光标的下一行/下一个位置粘贴</span><br><span class="line">    (27) u：撤销</span><br><span class="line">    (28) Ctrl + r：取消撤销</span><br><span class="line">    (29) 大于号 &gt;：将选中的文本整体向右缩进一次</span><br><span class="line">    (30) 小于号 &lt;：将选中的文本整体向左缩进一次</span><br><span class="line">    (31) :w 保存</span><br><span class="line">    (32) :w! 强制保存</span><br><span class="line">    (33) :q 退出</span><br><span class="line">    (34) :q! 强制退出</span><br><span class="line">    (35) :wq 保存并退出</span><br><span class="line">    (36) :set paste 设置成粘贴模式，取消代码自动缩进</span><br><span class="line">    (37) :set nopaste 取消粘贴模式，开启代码自动缩进</span><br><span class="line">    (38) :set nu 显示行号</span><br><span class="line">    (39) :set nonu 隐藏行号</span><br><span class="line">    (40) gg=G：将全文代码格式化</span><br><span class="line">    (41) :noh 关闭查找关键词高亮</span><br><span class="line">    (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令</span><br><span class="line">异常处理：</span><br><span class="line">    每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。</span><br><span class="line">    如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：</span><br><span class="line">        (1) 找到正在打开该文件的程序，并退出</span><br><span class="line">        (2) 直接删掉该swp文件即可</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>图论</title>
    <url>/2023/07/31/%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Flood-Fill"><a href="#1-Flood-Fill" class="headerlink" title="1.Flood Fill"></a>1.Flood Fill</h2><ol>
<li><p><a href="https://www.acwing.com/problem/content/description/1404/">星空之夜</a> <code>Flood Fill</code> <code>BFS</code> <code>哈希</code></p>
<p>本题主要是在使用Flood Fill寻找连通块的基础上，根据题目给出的条件，标上唯一标识，并且需要保证满足题目条件的图形的唯一标识相同</p>
<p><strong><code>求一个图形的hash值的常用作法：求图中每个点坐标的欧几里得距离并相加</code></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line">vector&lt;pii&gt; v;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_dict</span><span class="params">(pii a, pii b)</span> </span>&#123; <span class="comment">// 求欧几里得距离</span></span><br><span class="line">    <span class="type">double</span> dx = a.first - b.first;</span><br><span class="line">    <span class="type">double</span> dy = a.second - b.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_hash</span><span class="params">()</span> </span>&#123; <span class="comment">// 求每个图形对应的hash值</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); j ++)</span><br><span class="line">            sum += <span class="built_in">get_dict</span>(v[i], v[j]);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_id</span><span class="params">(<span class="type">double</span> hash)</span> </span>&#123; <span class="comment">// 查找该hash值对应的字母</span></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> h[<span class="number">30</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; id; i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(h[i] - hash) &lt; eps) <span class="keyword">return</span> i + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    h[id ++] = hash;</span><br><span class="line">    <span class="keyword">return</span> id - <span class="number">1</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123; <span class="comment">// 找出最大的连通块</span></span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    </span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        v.<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = dx[i] + t.first, ny = dy[i] + t.second;</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span>||nx &gt;= n || ny&lt;<span class="number">0</span> || ny&gt;=m || g[nx][ny] != <span class="string">&#x27;1&#x27;</span> || st[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">            st[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; g[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">                <span class="type">char</span> c = <span class="built_in">get_id</span>(<span class="built_in">get_hash</span>());</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : v) &#123;</span><br><span class="line">                    g[x.first][x.second] = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; g[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><a href="https://www.acwing.com/problem/content/description/2062/">奶牛选美</a> <code>Flood Fill</code> <code>DFS</code> <code>贪心</code></p>
<p>本题因为走的距离都是上下左右四个方向，所以假设最终结果为任意两个点之间的<code>曼哈顿距离</code>的最小值，可以用反证法进行证明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;pii&gt; vpi[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, vector&lt;pii&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">    g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m || g[nx][ny] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nx, ny, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++) cin &gt;&gt; g[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j, vpi[k ++]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">10000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a : vpi[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;b : vpi[<span class="number">1</span>])</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(a.first - b.first) + <span class="built_in">abs</span>(a.second - b.second) - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/4007/">传送阵</a> <code>Flood Fill</code> <code>枚举</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> r1,c1,r2,c2;</span><br><span class="line">vector&lt;pii&gt; vpi[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vpi[k].<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">    g[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; n || g[nx][ny] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nx, ny, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; r1 &gt;&gt; c1;</span><br><span class="line">    cin &gt;&gt; r2 &gt;&gt; c2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; g[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(r1, c1, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(r2, c2, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a : vpi[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;b : vpi[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, (a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><a href="https://www.acwing.com/problem/content/description/4711/">立方体</a> <code>Flood Fill</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[N][N][N];</span><br><span class="line"><span class="type">int</span> k, n, m;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;, dl[<span class="number">6</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    ans ++;</span><br><span class="line">    g[l][x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> nl = l + dl[i], nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nl &lt; <span class="number">1</span> || nl &gt; k || nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; m || g[nl][nx][ny] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nl, nx, ny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">1</span>;p&lt;=n;p++) </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">1</span>;q&lt;=m;q++) cin &gt;&gt; g[i][p][q];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-多源BFS"><a href="#2-多源BFS" class="headerlink" title="2.多源BFS"></a>2.多源BFS</h2><ol>
<li><p><a href="https://www.acwing.com/problem/content/175/">矩阵距离</a></p>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/5045/">病毒</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">queue&lt;pii&gt; q;</span><br><span class="line">pii ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i ++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x+dx[i], ny = y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;m|| g[nx][ny] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            g[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans = &#123;x, y&#125;;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">while</span>(k --)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x&gt;&gt; y;</span><br><span class="line">        g[x][y] = <span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout &lt;&lt; ans.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/3208/">最优配餐</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> n,m,k,dd;</span><br><span class="line"><span class="comment">// 分店 0 客户: 值代表餐的个数 不能行走 -1</span></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line">queue&lt;pii&gt; q;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i ++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x+dx[i], ny = y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">1</span> || nx&gt;n || ny&lt;<span class="number">1</span> || ny&gt;n || g[nx][ny] == <span class="number">-1</span> || d[nx][ny] != <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(d[nx][ny] &gt; d[x][y] + <span class="number">1</span>) &#123;</span><br><span class="line">                d[nx][ny] = d[x][y] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n,&amp;m,&amp;k,&amp;dd);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        g[x][y] = <span class="number">0</span>;</span><br><span class="line">        d[x][y] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">        e[i] = &#123;x,y,c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(dd--)&#123;</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        g[x][y] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)&#123;</span><br><span class="line">        ans += (<span class="type">long</span> <span class="type">long</span>)d[e[i].a][e[i].b] * e[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-最小步数模型"><a href="#3-最小步数模型" class="headerlink" title="3.最小步数模型"></a>3.最小步数模型</h2><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><ol>
<li><a href="https://www.acwing.com/problem/content/description/1109/">魔板</a></li>
</ol>
<h3 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h3><ol>
<li><p><a href="https://www.acwing.com/problem/content/192/">子串变换</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">string A, B;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line">string a[N],b[N];</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; Da, Db;</span><br><span class="line">queue&lt;string&gt; q1, q2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a-&gt;b拓展</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;string&gt; &amp;q, unordered_map&lt;string, <span class="type">int</span>&gt; &amp;da, unordered_map&lt;string, <span class="type">int</span>&gt; &amp;db, string a[], string b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = da[q.<span class="built_in">front</span>()];</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; da[q.<span class="built_in">front</span>()] == d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; t.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n; j++) <span class="comment">// 找到所有能进行替换的规则</span></span><br><span class="line">                <span class="keyword">if</span>(t.<span class="built_in">substr</span>(i, a[j].<span class="built_in">size</span>()) == a[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    string nows = t.<span class="built_in">substr</span>(<span class="number">0</span>, i) + b[j] + t.<span class="built_in">substr</span>(i + a[j].<span class="built_in">size</span>()); <span class="comment">// 替换后的字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (db.<span class="built_in">count</span>(nows)) <span class="comment">//说明双端都搜索到了，返回结果</span></span><br><span class="line">                        <span class="keyword">return</span> da[t] + <span class="number">1</span> + db[nows];</span><br><span class="line">                    <span class="keyword">if</span> (da.<span class="built_in">count</span>(nows)) <span class="keyword">continue</span>; <span class="comment">// 只需保证最优解即可</span></span><br><span class="line">                    da[nows] = da[t] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(nows);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q1.<span class="built_in">push</span>(A);</span><br><span class="line">    q2.<span class="built_in">push</span>(B);</span><br><span class="line">    Da[A]=<span class="number">0</span>;</span><br><span class="line">    Db[B]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双端拓展</span></span><br><span class="line">    <span class="keyword">while</span>(q1.<span class="built_in">size</span>() &amp;&amp; q2.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t; <span class="comment">// 拓展的步数</span></span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>()) </span><br><span class="line">            t = <span class="built_in">extend</span>(q1, Da, Db, a, b);</span><br><span class="line">        <span class="keyword">else</span> t = <span class="built_in">extend</span>(q2, Db, Da, b, a);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t &lt;= <span class="number">10</span>) <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a[n]&gt;&gt;b[n]) n++;</span><br><span class="line">    <span class="keyword">if</span>(A==B) </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">if</span>(ans &gt; <span class="number">10</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO ANSWER!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/179/">噩梦</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">810</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> st[N][N];</span><br><span class="line">PII ghost[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> tim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=n || y&lt;<span class="number">0</span> || y&gt;=m || g[x][y]==<span class="string">&#x27;X&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">abs</span>(x - ghost[i].first) + <span class="built_in">abs</span>(y - ghost[i].second) &lt;= <span class="number">2</span>*tim) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    PII boy, girl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;M&#x27;</span>) boy = &#123;i, j&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;G&#x27;</span>) girl = &#123;i, j&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;Z&#x27;</span>) ghost[cnt ++ ] = &#123;i, j&#125;;</span><br><span class="line">    queue&lt;PII&gt; q1, q2;</span><br><span class="line">    q1.<span class="built_in">push</span>(boy);</span><br><span class="line">    q2.<span class="built_in">push</span>(girl);</span><br><span class="line">    <span class="type">int</span> tim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q1.<span class="built_in">size</span>() || q2.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tim ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, len = q1.<span class="built_in">size</span>(); j &lt; len; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">check</span>(x, y, tim)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++ )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> a = x + dx[k], b = y + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">check</span>(a, b, tim)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (st[a][b] == <span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> tim;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!st[a][b])</span><br><span class="line">                    &#123;</span><br><span class="line">                        st[a][b] = <span class="number">1</span>;</span><br><span class="line">                        q1.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, len = q2.<span class="built_in">size</span>(); j &lt; len; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q2.<span class="built_in">front</span>();</span><br><span class="line">            q2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(x, y, tim)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a = x + dx[k], b = y + dy[k];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(a, b, tim))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (st[a][b] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> tim;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!st[a][b])</span><br><span class="line">                    &#123;</span><br><span class="line">                        st[a][b] = <span class="number">2</span>;</span><br><span class="line">                        q2.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">bfs</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="4-双端队列BFS"><a href="#4-双端队列BFS" class="headerlink" title="4.双端队列BFS"></a>4.双端队列BFS</h2><p><code>解决问题：双端队列主要解决图中边的权值只有0或者1的最短路问题</code> </p>
<h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><p>每次从队头取出元素，并进行拓展其他元素时</p>
<ul>
<li>若拓展某一元素的边权是0，则将该元素插入到队头</li>
<li>若拓展某一元素的边权是1，则将该元素插入到队尾</li>
</ul>
<p><strong>与堆优化Dijkstra 一样，必须在出队时才知道每个点最终的最小值，而和一般的bfs不一样。原因主要是存在边权为0的边，这样可能会导致出现多个边权为0的边累加在一起导致真正的边权很小的情况发生</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol>
<li><p><a href="https://www.acwing.com/problem/content/177/">电路维修</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;; <span class="comment">// 要到达的点的坐标的偏移值</span></span><br><span class="line"><span class="type">int</span> ix[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, iy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 要到达的点的坐标的所表示的符合的偏移值</span></span><br><span class="line"><span class="type">char</span> cc[] = &#123;<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>&#125;; <span class="comment">// 顺时针方向的符合条件的符合内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;pii&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">        <span class="keyword">if</span>(x == n &amp;&amp; y == m) <span class="keyword">return</span> d[x][y];</span><br><span class="line">        <span class="keyword">if</span>(st[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        st[x][y] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt; n || ny &lt; <span class="number">0</span> || ny &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> gx = x + ix[i], gy = y + iy[i];</span><br><span class="line">            <span class="type">int</span> w = g[gx][gy] != cc[i];</span><br><span class="line">            <span class="keyword">if</span>(d[nx][ny] &gt; w + d[x][y])</span><br><span class="line">            &#123;</span><br><span class="line">                d[nx][ny] = w + d[x][y];</span><br><span class="line">                <span class="keyword">if</span>(!w) q.<span class="built_in">push_front</span>(&#123;nx, ny&#125;);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(&#123;nx, ny&#125;);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; g[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n + m &amp; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO SOLUTION&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/2062/">奶牛选美</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;pii&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[x][y] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(g[x][y] == <span class="string">&#x27;X&#x27;</span> &amp;&amp; d[x][y]) <span class="keyword">return</span> d[x][y];</span><br><span class="line">        <span class="keyword">if</span>(st[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        st[x][y] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span>||nx &gt;=n ||ny&lt;<span class="number">0</span>||ny&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> w = g[nx][ny] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(d[nx][ny] &gt; d[x][y] + w)</span><br><span class="line">            &#123;</span><br><span class="line">                d[nx][ny] = d[x][y] + w;</span><br><span class="line">                <span class="keyword">if</span>(!w) q.<span class="built_in">push_front</span>(&#123;nx, ny&#125;);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++) cin &gt;&gt; g[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">bfs</span>(i, j);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/342/">通信线路</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N],w[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="type">int</span> ww = w[i] &gt; mid;</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; d[t] + ww) &#123;</span><br><span class="line">                d[j] = d[t] + ww;</span><br><span class="line">                <span class="keyword">if</span>(!ww) q.<span class="built_in">push_front</span>(j);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">1e9</span>) cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/2021/">拖拉机</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,x,y;</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;pii&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[x][y] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!t.first &amp;&amp; !t.second) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = t.first + dx[i], ny = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; N) &#123;</span><br><span class="line">                <span class="type">int</span> w = (g[nx][ny]) == <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(d[nx][ny] &gt; d[t.first][t.second] + w) &#123;</span><br><span class="line">                    d[nx][ny] = d[t.first][t.second] + w;</span><br><span class="line">                    <span class="keyword">if</span>(!w) q.<span class="built_in">push_front</span>(&#123;nx, ny&#125;);</span><br><span class="line">                    <span class="keyword">else</span> q.<span class="built_in">push_back</span>(&#123;nx, ny&#125;);</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout &lt;&lt; d[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/3678/">逃离迷宫</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n, m, k, x1,y1,x2,y2;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> d[N][N][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;E&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push_back</span>(&#123;x1, y1, i&#125;);</span><br><span class="line">        d[x1][y1][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="type">int</span> x = t.x, y = t.y, z = t.z;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x == x2 &amp;&amp; y == y2) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dx[i],ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;=<span class="number">0</span>||nx&gt;n||ny&lt;=<span class="number">0</span>||ny&gt;m||g[nx][ny]==<span class="string">&#x27;*&#x27;</span>)  <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> w = z != i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(d[nx][ny][i] &gt; d[x][y][z] + w) &#123;</span><br><span class="line">                d[nx][ny][i] = d[x][y][z] + w;</span><br><span class="line">                <span class="keyword">if</span>(!w) q.<span class="built_in">push_front</span>(&#123;nx,ny, i&#125;);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(&#123;nx, ny, i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; g[i] + <span class="number">1</span>;;</span><br><span class="line">        cin &gt;&gt; k&gt;&gt; y1&gt;&gt;x1&gt;&gt;y2&gt;&gt;x2;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="type">bool</span> is = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i ++)</span><br><span class="line">            <span class="keyword">if</span>(d[x2][y2][i] &lt;= k) &#123;</span><br><span class="line">                is = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(is) <span class="built_in">puts</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong><a href="https://www.acwing.com/problem/content/description/4484/">方格探索 </a></strong> <code>思考题</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,m,sx,sy,X,Y;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    deque&lt;pii&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;sx, sy&#125;);</span><br><span class="line">    d[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[t.x][t.y]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.x][t.y] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nx=t.x+dx[i],ny=t.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;n||ny&lt;<span class="number">1</span>||ny&gt;m||g[nx][ny]==<span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> w = i == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(d[nx][ny] &gt; d[t.x][t.y]+w)&#123;</span><br><span class="line">                d[nx][ny]=d[t.x][t.y]+w;</span><br><span class="line">                <span class="keyword">if</span>(w)q.<span class="built_in">push_back</span>(&#123;nx,ny&#125;);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_front</span>(&#123;nx,ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;sx,&amp;sy,&amp;X,&amp;Y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;g[i]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> b = d[i][j];</span><br><span class="line">            <span class="keyword">if</span>(b &lt;= Y &amp;&amp; b - (j - sy) &lt;= X) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="5-BFS"><a href="#5-BFS" class="headerlink" title="5.BFS"></a>5.BFS</h2><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><p>​    <code>一般适用于边权为1的最短路问题</code></p>
<ol>
<li><p><a href="https://www.acwing.com/problem/content/description/1078/">迷宫问题</a></p>
</li>
<li><p><a href="https://www.acwing.com/problem/content/190/">武士风度的牛</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>,<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    d[x][y] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = t.first + dx[i], ny = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[nx][ny] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            d[nx][ny] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[nx][ny] == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">                ans = d[nx][ny];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g[nx][ny] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; g[i];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;K&#x27;</span>) <span class="built_in">bfs</span>(i, j);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/1102/">抓住那头牛</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line">    d[n]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t==k) <span class="keyword">return</span> d[k];</span><br><span class="line">        <span class="keyword">if</span>(t+<span class="number">1</span> &lt; N &amp;&amp; d[t+<span class="number">1</span>]==<span class="number">-1</span>)&#123;</span><br><span class="line">            d[t+<span class="number">1</span>]=d[t]+<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; d[t<span class="number">-1</span>]==<span class="number">-1</span>)&#123;</span><br><span class="line">            d[t<span class="number">-1</span>]=d[t]+<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t*<span class="number">2</span>&lt;N &amp;&amp; d[t*<span class="number">2</span>]==<span class="number">-1</span>)&#123;</span><br><span class="line">            d[t*<span class="number">2</span>]=d[t]+<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.matiji.net/exam/brushquestion/1/4347/179CE77A7B772D15A8C00DD8198AAC74?from=1">公园</a> <code>bfs</code> </p>
<p>根据题意可得，起点分别为 $T$ , $F$, 终点为 $N$ 。</p>
<ul>
<li>所以假设它们之间通过 $X$ 进行相连 (起点在 $X$ 汇合后与终点相连)，则最短距离为 $d[T][X] + d[F][X] + d[N][X]$ 的最短距离的和，再分别乘上所需的代价即可。</li>
<li>如果未进行汇合，则直接求 $d[T][X] + d[F][X]$ 的最短路即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> te,fe,S;</span><br><span class="line"><span class="type">int</span> t,f,n,m;</span><br><span class="line"><span class="type">int</span> d[<span class="number">3</span>][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> d[], <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> <span class="number">4</span>*N);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; d[t] + <span class="number">1</span>) &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    cin&gt;&gt;te&gt;&gt;fe&gt;&gt;S;</span><br><span class="line">    cin&gt;&gt;t&gt;&gt;f&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cal</span>(d[<span class="number">0</span>], t);</span><br><span class="line">    <span class="built_in">cal</span>(d[<span class="number">1</span>], f);</span><br><span class="line">    <span class="built_in">cal</span>(d[<span class="number">2</span>], n);</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">0</span>][i] != INF &amp;&amp; d[<span class="number">1</span>][i] != INF &amp;&amp; d[<span class="number">2</span>][i] != INF) </span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="number">1ll</span> * d[<span class="number">0</span>][i] * te + <span class="number">1ll</span> * d[<span class="number">1</span>][i] * fe + <span class="number">1ll</span> * d[<span class="number">2</span>][i] * (te + fe - S) );</span><br><span class="line">    cout &lt;&lt; (ans == <span class="number">1e18</span> ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-DFS"><a href="#6-DFS" class="headerlink" title="6.DFS"></a>6.DFS</h2><h3 id="DFS的连通性"><a href="#DFS的连通性" class="headerlink" title="DFS的连通性"></a>DFS的连通性</h3><ol>
<li><p><a href="https://www.acwing.com/problem/content/1115/">红与黑</a> <code>Flood Fill</code> <code>无需恢复现场</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> sx,sy;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    ans ++;</span><br><span class="line">    g[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(g[nx][ny] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nx, ny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;m&gt;&gt;n, n &amp;&amp; m) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                cin &gt;&gt; g[i][j];</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                    sx = i,sy=j;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(sx, sy);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="DFS之顺序搜索"><a href="#DFS之顺序搜索" class="headerlink" title="DFS之顺序搜索"></a>DFS之顺序搜索</h3><ol>
<li><p><a href="http://bailian.openjudge.cn/practice/4123/">马走日</a> <code>需要回溯</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>,<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n * m) &#123;</span><br><span class="line">        ans ++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> nx=x+dx[i],ny=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||nx&gt;=n||ny&lt;<span class="number">0</span>||ny&gt;=m||st[nx][ny])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nx,ny,cnt+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    st[x][y]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y, <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="">单词接龙</a>(<a href="https://ac.nowcoder.com/acm/problem/16752">https://ac.nowcoder.com/acm/problem/16752</a>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>;</span><br><span class="line">string word[N];</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 保存每个单词之间能进行连接的最小长度</span></span><br><span class="line"><span class="type">int</span> n, ans;  </span><br><span class="line"><span class="type">int</span> used[N]; <span class="comment">// 每个单词使用的次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, (<span class="type">int</span>)s.<span class="built_in">size</span>());</span><br><span class="line">    used[last] ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(g[last][i] &amp;&amp; used[i] &lt; <span class="number">2</span>) </span><br><span class="line">            <span class="built_in">dfs</span>(s + word[i].<span class="built_in">substr</span>(g[last][i]), i);</span><br><span class="line">    used[last] --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i ++) cin &gt;&gt; word[i];</span><br><span class="line">    <span class="type">char</span> start;</span><br><span class="line">    cin &gt;&gt; start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            string a = word[i], b = word[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="built_in">min</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()); k ++)</span><br><span class="line">                <span class="keyword">if</span>(a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() - k, k) == b.<span class="built_in">substr</span>(<span class="number">0</span>, k))</span><br><span class="line">                &#123;</span><br><span class="line">                    g[i][j] = k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(word[i][<span class="number">0</span>] == start)</span><br><span class="line">            <span class="built_in">dfs</span>(word[i], i);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/T175410">分成互质组</a> <code>重点</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 保存每组的数据的下标</span></span><br><span class="line"><span class="type">int</span> n, ans = N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> group[],<span class="type">int</span> gc, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gc; i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">gcd</span>(p[group[i]], p[t]) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// u: 当前的组 gc：当前组的下个数的下标 tc：当前所使用的总数 start：枚举下次数的开始</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> gc, <span class="type">int</span> tc, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tc == n) ans = u;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> is = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!st[i] &amp;&amp; <span class="built_in">check</span>(g[u], gc, i)) <span class="comment">// 如果该数为访问，且可以加入该组</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            g[u][gc] = i;</span><br><span class="line">            <span class="built_in">dfs</span>(u, gc + <span class="number">1</span>, tc + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            is = <span class="literal">false</span>;</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(is) <span class="built_in">dfs</span>(u + <span class="number">1</span>, <span class="number">0</span>, tc, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; p[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/167/">小猫爬山</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cat[N], sum[N];</span><br><span class="line"><span class="type">int</span> n, m, ans = N;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span> <span class="comment">// u 当前的猫的个数 k 当前的车数，第几辆车，sum[k] 该车的总容量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">        <span class="keyword">if</span> (cat[u] + sum[i] &lt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i] += cat[u];</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, k);</span><br><span class="line">            sum[i] -= cat[u];</span><br><span class="line">        &#125;</span><br><span class="line">    sum[k + <span class="number">1</span>] = cat[u];</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">    sum[k + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; cat[i];</span><br><span class="line">    <span class="built_in">sort</span>(cat, cat + n, cmp);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/169/">木棒</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">70</span>;</span><br><span class="line"><span class="type">int</span> w[N], sum, len;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="comment">// u 当前的木棒数 s 当前使用木棍拼接木棒的长度 i 当前使用的木棍</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> s,<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u * len == sum) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到符合条件的长度便退出</span></span><br><span class="line">    <span class="keyword">if</span>(s==len) <span class="keyword">return</span> <span class="built_in">dfs</span>(u+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// 当前木棒已拼接完成，继续下一次拼接</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(s+w[i]&gt;len) <span class="keyword">continue</span>; <span class="comment">//可行性剪枝</span></span><br><span class="line">        </span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(u,s+w[i],i+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 当前木棍符合条件，继续下一个</span></span><br><span class="line">        st[i]=<span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s+w[i]==len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前长度的木棍不符合条件，说明后面与它相同长度的也不符合条件</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; w[i]==w[j]) j++;</span><br><span class="line">        i = j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n)&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;w[i], sum+=w[i];</span><br><span class="line">        <span class="built_in">sort</span>(w, w+n);</span><br><span class="line">        <span class="built_in">reverse</span>(w,w+n);</span><br><span class="line">        len=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum % len ==<span class="number">0</span> &amp;&amp; <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">if</span>(len&gt;sum)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h3><ol>
<li><p><a href="">加成序列</a>(<a href="https://www.acwing.com/problem/content/description/172/">https://www.acwing.com/problem/content/description/172/</a>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">int</span> n,cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="comment">// 迭代加深，每次只搜索给定范围内的节点</span></span><br><span class="line"><span class="comment">// u 当前的层数 depth 最大的层数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u&gt;depth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(path[u<span class="number">-1</span>]==n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=u<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s=path[i]+path[u<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s &gt; n || st[s]) <span class="keyword">continue</span>;</span><br><span class="line">        st[s]=<span class="literal">true</span>;</span><br><span class="line">        path[u]=s;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(u+<span class="number">1</span>, depth)) </span><br><span class="line">        &#123;</span><br><span class="line">            st[s]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st[s]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    path[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)&#123;</span><br><span class="line">        <span class="type">int</span> dep=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">dfs</span>(<span class="number">1</span>, dep)) dep++;<span class="comment">//从大到小枚举长度，求得最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dep;i++)cout&lt;&lt;path[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/189/">导弹防御系统</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> up[N], down[N]; <span class="comment">// 保存所有上升序列的最大值， 保存所有下降序列的最小值</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> de, <span class="type">int</span> u, <span class="type">int</span> su, <span class="type">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(su + sd &gt; de) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(u == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> is = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举放到上升子序列中的情况</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= su; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (up[i] &lt; w[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = up[i];</span><br><span class="line">            up[i] = w[u];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(de, u + <span class="number">1</span>, su, sd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            up[i] = t;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        up[su + <span class="number">1</span>] = w[u];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(de, u + <span class="number">1</span>, su + <span class="number">1</span>, sd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    flag = <span class="literal">false</span>;    </span><br><span class="line">    <span class="comment">// 寻找符合条件的下降序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sd;i++)</span><br><span class="line">        <span class="keyword">if</span>(down[i] &gt; w[u]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = down[i];</span><br><span class="line">            down[i] = w[u];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(de, u + <span class="number">1</span>, su, sd)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            down[i] = t;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">        down[sd + <span class="number">1</span>] = w[u];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(de, u + <span class="number">1</span>, su, sd + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; w[i];</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">dfs</span>(depth, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) depth ++;</span><br><span class="line">        cout &lt;&lt; depth &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;x	</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/188/">巴士</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="comment">// 枚举所有可能出现的路线</span></span><br><span class="line"><span class="comment">// 从路线能容纳最多车的路线开始枚举</span></span><br><span class="line"><span class="comment">// 使用迭代加深枚举从小到大寻找符合条件的路线数量</span></span><br><span class="line"><span class="type">int</span> bus[M];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,pii&gt;&gt; v;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a; i &lt; <span class="number">60</span>; i += d)</span><br><span class="line">    <span class="keyword">if</span> (!bus[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> u, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!depth) <span class="keyword">return</span> u == n; <span class="comment">//观察路线数已经使用完时，是否还有车辆剩余</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;v.<span class="built_in">size</span>();i++)&#123; <span class="comment">//选择哪个路线</span></span><br><span class="line">        <span class="keyword">auto</span> r = v[i];</span><br><span class="line">        <span class="type">int</span> a=r.second.first, d=r.second.second;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(a, d)) <span class="keyword">continue</span>; <span class="comment">//该时间段无连续到站的车辆</span></span><br><span class="line">        <span class="keyword">if</span>(depth*r.first + u &lt; n) <span class="keyword">continue</span>; <span class="comment">// 因为是按照从大到小枚举的，如果剩余的路线都按照当前能达到的车辆数取依然不满足条件，就进行剪枝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=a;j&lt;<span class="number">60</span>;j+=d) bus[j]--;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(depth - <span class="number">1</span>, u + r.first, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=a;j&lt;<span class="number">60</span>;j+=d) bus[j]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        bus[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">60</span>;a++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=a+<span class="number">1</span>;a+d&lt;<span class="number">60</span>;d++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(a, d))</span><br><span class="line">                <span class="comment">// 存储a-d这个时间间隔内；连续到站出现的公交车数量</span></span><br><span class="line">                v.<span class="built_in">push_back</span>(&#123;(<span class="number">59</span> - a)/d+<span class="number">1</span>, &#123;a,d&#125;&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),greater&lt;pair&lt;<span class="type">int</span>, pii&gt;&gt;());</span><br><span class="line">    <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">dfs</span>(depth, <span class="number">0</span>, <span class="number">0</span>)) depth++;</span><br><span class="line">    cout&lt;&lt;depth&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="7-单源最短路"><a href="#7-单源最短路" class="headerlink" title="7.单源最短路"></a>7.单源最短路</h2><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><ul>
<li><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>时间复杂度：$O(n^3)$</li>
</ul>
</li>
<li><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4></li>
</ul>
<ol>
<li><p><a href="https://www.luogu.com.cn/problem/U167571">信使</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        d[a][b] = d[b][a] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);          </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">1</span>][i] == <span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, d[<span class="number">1</span>][i]);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><ul>
<li><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul>
<li>时间复杂度：$O(m)$    最坏：$O(nm)$</li>
</ul>
</li>
<li><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4></li>
</ul>
<ol>
<li><p><a href="https://www.acwing.com/problem/content/1129/">香甜的黄油</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N],h[N],ne[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> id[N], d[N];</span><br><span class="line"><span class="type">int</span> n,p,m;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[idx] = b,w[idx] = c,ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    d[start] = <span class="number">0</span>;</span><br><span class="line">    st[start] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; d[t] + w[i]) &#123;</span><br><span class="line">                d[j] = d[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>; q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(d[id[i]] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">else</span> ans += d[id[i]]; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; id[i];</span><br><span class="line">    <span class="keyword">while</span>(m --) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c), <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i++) ans = <span class="built_in">min</span>(ans, <span class="built_in">spfa</span>(i));</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><ul>
<li><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4></li>
<li><h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><ol>
<li><p><a href="https://www.luogu.com.cn/problem/P1576">最小花费</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2100</span>;</span><br><span class="line"><span class="type">int</span> n,m, A, B;</span><br><span class="line"><span class="type">double</span> g[N][N];</span><br><span class="line"><span class="type">double</span> d[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="comment">// 设每次转账后的数据为100*w1*w2*...*wk,因为结果和初始值不变，所以只需使w1*w2*...*wk最大即可，即logw1 + logw2 + .. +logwk最大</span></span><br><span class="line"><span class="comment">// 又因为0&lt;w&lt;1,所以使-logw + (-logwk)最小即可即 d[j] = min(d[j], d[t] + (-logw)); 再相反，即求最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    d[A]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; d[t] &lt;= d[j])</span><br><span class="line">                t=j;</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            d[j]=<span class="built_in">max</span>(d[j], d[t]*g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="type">double</span> z=(<span class="number">100.0</span>-c)/<span class="number">100</span>;</span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">max</span>(g[a][b], z);</span><br><span class="line">    &#125;    </span><br><span class="line">    cin&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.8lf&quot;</span>, <span class="number">100</span>/d[B]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/905/">昂贵的聘礼</a> <code>范围的限制</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> level[N];</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> E)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++) <span class="comment">// 需要保证每次都能找出最小值</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || d[j] &lt; d[t])) t = j;</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(level[j]&gt;=S &amp;&amp;  level[j]&lt;=E) d[j] = <span class="built_in">min</span>(d[j], d[t]+w[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> price, cnt;</span><br><span class="line">        cin&gt;&gt;price&gt;&gt;level[i]&gt;&gt;cnt;</span><br><span class="line">        w[<span class="number">0</span>][i] = <span class="built_in">min</span>(w[<span class="number">0</span>][i], price); <span class="comment">//代表购买该物品的初始价格</span></span><br><span class="line">        <span class="keyword">while</span>(cnt --)&#123;</span><br><span class="line">            <span class="type">int</span> id, cost;</span><br><span class="line">            cin&gt;&gt;id&gt;&gt;cost;</span><br><span class="line">            w[id][i] = <span class="built_in">min</span>(w[id][i], cost); <span class="comment">// 代表平替物品的价格</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="comment">// 枚举所有满足等级限制的区间</span></span><br><span class="line">    <span class="comment">// [level[1] - m, level[1] + m];枚举满足该区间的所有点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = level[<span class="number">1</span>]-m; i &lt;= level[<span class="number">1</span>]; i ++)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">dijkstra</span>(i, i + m));</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P5764">新年好</a>    <code>DFS</code>  <code>堆优化版的Dijkstra</code> <code>卡SPFA</code></p>
<p>题目本意求按某种顺序遍历所有边的情况下的最短路径，所以我们可以DFS找出所有的顺序，然后求按照这个顺序执行时，求两点之间的最小路径的和即可，为了避免超时，先预处理求从所有点出发的最短路径，即任意两点之间的最短路径，然后通过枚举顺序找最小值，即最终结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = <span class="number">2e5</span>+<span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> dict[<span class="number">6</span>][N]; <span class="comment">// 以任意车站为起点的，到其他车站的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> d[])</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, N * <span class="number">4</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.second, dd = t.first;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; dd + w[i]) &#123;</span><br><span class="line">                d[j] = dd + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;d[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// u:当前遍历的节点的个数  start：当前遍历节点的开始节点的下标 sum：当前的距离总和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> start, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">6</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="type">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">            <span class="type">int</span> ne = a[i]; </span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(u + <span class="number">1</span>, i, sum + dict[start][ne]));</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">while</span>(m --) &#123;</span><br><span class="line">      <span class="type">int</span> a,b,c;</span><br><span class="line">      cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">      <span class="built_in">add</span>(a,b,c), <span class="built_in">add</span>(b,a,c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) <span class="built_in">dijkstra</span>(a[i], dict[i]);</span><br><span class="line">  <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">  cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/344/">道路与航线</a></p>
<ul>
<li><p>常规作法，会被卡 <code>SPFA</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25010</span>, M = <span class="number">2e5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, r, p, s;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    st[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];~i;i=ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; d[t] + w[i]) &#123;</span><br><span class="line">                d[j] = d[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r&gt;&gt;p&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(r --)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p --) &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i] == INF) cout &lt;&lt; <span class="string">&quot;NO PATH&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; d[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>topo</code>与堆优化版的<code>dijkstra</code>进行优化</p>
<ol>
<li>道路是双向且权值为正，所以可以使用dijkstra进行求解。</li>
<li>由题意可得，图是无环存在的，且航线是通过单向边进行连接的，所以所有组成道路的边可以看出一个连通块，连通块之间通过航线进行连接，可以直接通过topo排序求解最小值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25010</span>, M = <span class="number">150010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> id[N]; <span class="comment">// 每个节点对应的连通块编号</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; block[N]; <span class="comment">// 对应的连通块，每个连通块包含所有连通城市的下标</span></span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="type">int</span> n,R,P,S;</span><br><span class="line"><span class="type">int</span> bcnt; <span class="comment">// 当前连通块的编号，也是数目</span></span><br><span class="line"><span class="type">int</span> din[N]; <span class="comment">// 存每个连通块的入度数</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// 存储每个入度为0的连通块</span></span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使与u相连的城市合并到一个连通块中，编号为bid</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> bid)</span></span>&#123;</span><br><span class="line">    id[u]=bid;</span><br><span class="line">    block[bid].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];~i;i=ne[i])&#123; <span class="comment">// 寻找与它相连的且未被合并到连通块中的点</span></span><br><span class="line">        <span class="type">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!id[j])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j, bid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> bid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为每个连通块不知道起点是谁，所以将所有点加入队列，当做起点</span></span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ver : block[bid]) heap.<span class="built_in">push</span>(&#123;d[ver], ver&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.second, dict = t.first;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>; st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[ver];~i;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; d[ver] + w[i]) &#123;</span><br><span class="line">                d[j] = d[ver] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (id[j] == id[ver]) heap.<span class="built_in">push</span>(&#123;d[j], j&#125;); <span class="comment">// 属于同一连通块</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (id[j] != id[ver] &amp;&amp; -- din[id[j]] == <span class="number">0</span>) q.<span class="built_in">push</span>(id[j]);  <span class="comment">// 不属于同一连通块，将其入度减一，为0则加入队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照toposort的顺序遍历每个点，可以求每个点的最小路，因为所有前置路径都已经被考虑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将入度为0的点入队   </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=bcnt;i++)</span><br><span class="line">        <span class="keyword">if</span>(!din[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">dijkstra</span>(t); <span class="comment">// 对每个入度为0的连通块求最短路</span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n,&amp;R,&amp;P,&amp;S);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(R --)&#123; <span class="comment">// 道路</span></span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将有道路相连的城市处理成连通块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!id[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i, ++ bcnt);</span><br><span class="line">    <span class="keyword">while</span>(P--) &#123; <span class="comment">// 航线</span></span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        din[id[b]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">toposort</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) </span><br><span class="line">        <span class="keyword">if</span>(d[i] &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO PATH&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/U263107">选择最佳线路</a>  <code>虚拟源点</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="comment">// 虚拟源点</span></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> ori[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	<span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">	d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || d[j]&lt;d[t])) t=j;</span><br><span class="line">		st[t]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">			d[j]=<span class="built_in">min</span>(d[j], d[t]+g[t][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(d[s] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> d[s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&gt;&gt;s)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">		<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">			<span class="type">int</span> a,b,c;</span><br><span class="line">			cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">			g[a][b]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> num;</span><br><span class="line">		cin&gt;&gt;num;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			g[<span class="number">0</span>][x] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/385/">观光</a></p>
<p>对求距离的数组进行状态划分，<code>d[i, 0]</code> 代表最短路，<code>d[i, 1]</code> 代表求次短路\</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> T, n, m;</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">2</span>], cnt[N][<span class="number">2</span>]; <span class="comment">// 存储不同类型的最短距离和路线的个数</span></span><br><span class="line"><span class="type">bool</span> st[N][<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> ver, tp, dist;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> E &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dist &gt; x.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最短路的类型是0， 次短路的类型是1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    priority_queue&lt;E, vector&lt;E&gt;, greater&lt;E&gt; &gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;s, <span class="number">0</span>, <span class="number">0</span>&#125;); <span class="comment">// 最短路</span></span><br><span class="line">    d[s][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    cnt[s][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.ver, tp = t.tp, dd = t.dist, count = cnt[ver][tp];</span><br><span class="line">        <span class="keyword">if</span>(st[ver][tp]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver][tp] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j][<span class="number">0</span>] &gt; dd + w[i]) &#123; <span class="comment">// 最短路需要被更新，次短路变成当前的最短路</span></span><br><span class="line">                d[j][<span class="number">1</span>] = d[j][<span class="number">0</span>];</span><br><span class="line">                cnt[j][<span class="number">1</span>] = cnt[j][<span class="number">0</span>];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, d[j][<span class="number">1</span>]&#125;);</span><br><span class="line">                d[j][<span class="number">0</span>] = dd + w[i];</span><br><span class="line">                cnt[j][<span class="number">0</span>] = count;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">0</span>, d[j][<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[j][<span class="number">0</span>] == dd + w[i]) cnt[j][<span class="number">0</span>] += count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[j][<span class="number">1</span>] &gt; dd + w[i]) &#123;</span><br><span class="line">                d[j][<span class="number">1</span>] = dd + w[i];</span><br><span class="line">                cnt[j][<span class="number">1</span>] = count;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, d[j][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(d[j][<span class="number">1</span>] == dd + w[i]) cnt[j][<span class="number">1</span>] += count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = cnt[f][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(d[f][<span class="number">0</span>] + <span class="number">1</span> == d[f][<span class="number">1</span>]) res += cnt[f][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="type">int</span> a,b,c;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s,f;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;f;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dijkstra</span>(s, f) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ul>
<li><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><ul>
<li>每个点只入队和出队一次</li>
</ul>
</li>
<li><h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><ol>
<li><p><a href="https://www.acwing.com/problem/content/description/922/">最优乘车</a></p>
<p>设置如果在同一条线路的站台的乘车代价为1，所以可以根据路线的顺序建立一张单向图，可以相连的边的边权都为1，所以可以使用BFS求最短路，最后减去第一乘车的代价即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">int</span> stop[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(g[t][i] == <span class="number">1</span> &amp;&amp; d[i] &gt; d[t] + <span class="number">1</span>) &#123;</span><br><span class="line">                d[i] = d[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == n) <span class="keyword">return</span>; q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line">        <span class="function">stringstream <span class="title">ssin</span><span class="params">(line)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, p;</span><br><span class="line">        <span class="keyword">while</span>(ssin &gt;&gt; p) stop[cnt ++] = p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cnt; k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = k; j &lt; cnt; j++)</span><br><span class="line">                g[stop[k]][stop[j]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">if</span>(d[n] == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; d[n] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P1144">最短路计数</a></p>
<p><code>cnt[i]</code> 记录的是以<code>i</code>为终点的路径的最短路的个数</p>
<ul>
<li>使用BFS求最短路，如果当前节点的下一个节点的最短路未确定，那么下一个节点的最短路径个数与当前的最短路径个数相同。</li>
<li>如果当前节点的下一个节点的最短路已经求出，那么就更新总的最短路，即当前节点的个数与之前的个数的和。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>, M = <span class="number">2</span> * N, MOD = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// 统计每个点的最短路的个数</span></span><br><span class="line"><span class="type">int</span> n,m,d[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>; cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[t]) <span class="keyword">continue</span>; </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i =ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; d[t] + <span class="number">1</span>) &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">                cnt[j] = cnt[t];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[j] == d[t] + <span class="number">1</span>) cnt[j] = (cnt[j] + cnt[t]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; cnt[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="8-Floyd"><a href="#8-Floyd" class="headerlink" title="8.Floyd"></a>8.Floyd</h2><h3 id="原理-动态规划"><a href="#原理-动态规划" class="headerlink" title="原理  (动态规划)"></a>原理  (动态规划)</h3><ol>
<li>定义一个状态数组 <code>d[k,i,j]</code> <ul>
<li>状态定义：从<code>i</code>节点走到<code>j</code>节点，且中间遍历的所有节点的编号不超过<code>k</code>的所有路径。</li>
<li>状态属性：求最小值。</li>
</ul>
</li>
<li>状态计算 <code>d[k,i,j]</code> <ul>
<li>如果当前路径不经过编号为<code>k</code>的节点，则状态转移方程为 <code>d[k,i,j] = d[k - 1,i,j]</code>。</li>
<li>反之，我们可以通过对<code>(i, j)</code>区间内的节点进行划分，状态转移方程为 <code>d[k,i,j] = d[k - 1,i,k] + d[k - 1,k,j]</code></li>
<li>所以最终结果为上述两种情况的最小值。</li>
</ul>
</li>
<li>优化空间: 可以去掉第一个属性，因为每次进行计算时，使用的都是上一层的数据，无需进行保存</li>
</ol>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">if</span>(i == j) g[i][j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> g[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h3><ol>
<li><p><a href="https://www.luogu.com.cn/problem/P1522">牛的旅行</a>  <code>思考题</code>  <code>dfs求连通块</code>  <code>floyd</code></p>
<ul>
<li>求每个牧区属于同一个牧场的连通块</li>
<li>求每个牧场中每个牧区在其中与其他牧区连接的最短距离的最大值</li>
<li>求任意两个牧场进行连接后的最小直径<ul>
<li>最小直径有新连接上的边</li>
<li>最小直径为新连接上的边，是原来两个牧场的直径的最大值</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> INF = <span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">pii p[N]; <span class="comment">// 存储牧区的坐标</span></span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存储点与点之间的关系</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> id[N], idx; <span class="comment">// 节点所属的连通块 连通块编号</span></span><br><span class="line"><span class="type">double</span> d[N][N], maxd[N];</span><br><span class="line"><span class="type">double</span> blockMax[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id[u]) <span class="keyword">return</span>;</span><br><span class="line">    id[u] = idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(g[u][i] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(i); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx=a.first-b.first;</span><br><span class="line">    <span class="type">double</span> dy=a.second-b.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx + dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; g[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求连通块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!id[i]) idx++, <span class="built_in">dfs</span>(i);  </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 最短路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(i != j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;1&#x27;</span>) d[i][j] = <span class="built_in">get</span>(p[i], p[j]);</span><br><span class="line">                <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// floyd</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">                </span><br><span class="line">    <span class="comment">// 每个牧区在它所在的牧场与其他点的最大的最短距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(d[i][j] &lt; INF) maxd[i] = <span class="built_in">max</span>(maxd[i], d[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; i++) <span class="comment">// 求每个牧场的直径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> x = -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(id[j] == i) x = <span class="built_in">max</span>(x, maxd[j]);</span><br><span class="line">        blockMax[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(d[i][j] &gt;= INF)</span><br><span class="line">             ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>( <span class="built_in">get</span>(p[i], p[j]) + maxd[i] + maxd[j], <span class="built_in">max</span>(blockMax[id[i]], blockMax[id[j]]) ) );</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, ans);     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/345/">排序</a>  <code>传递闭包</code></p>
<ul>
<li>状态方程的定义为：<code>f[k,i,j]</code> 代表编号经过不超过<code>k</code>的所有节点，且从<code>i</code>到<code>j</code>的所有路径。</li>
<li>状态方程的属性为：从<code>i</code>到<code>j</code>是否处于连通状态, <code>1代表连通，0代表不连通</code>。</li>
<li>状态方程的计算为：<ul>
<li>如果不经过节点<code>k</code>, <code>f[i,j] = f[i,j]</code> 即不发生变化</li>
<li>如果经过节点<code>k</code>, <code>f[i,j] = f[i,k] &amp; f[k,j]</code></li>
</ul>
</li>
<li>对出现的情况进行判断，如果<code>f[i,i] = 1</code>代表可能出现<code>A-&gt;B</code>,<code>B-&gt;A</code>的情况，所以出现矛盾, 如果<code>f[i,j] == 0 &amp;&amp; f[j,i] == 0</code>说明无法确定<code>i</code>与<code>j</code>之间的关系。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> d[N][N], g[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span>(!d[i][j]) d[i][j] = d[i][k] &amp; d[k][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 出现矛盾</span></span><br><span class="line">        <span class="keyword">if</span>(d[i][i]) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(!d[i][j] &amp;&amp; !d[j][i]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不能确定情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 可以确定关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">            <span class="type">bool</span> is = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span>(!st[j] &amp;&amp; d[j][i]) &#123;</span><br><span class="line">                    is = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(is) &#123;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m, n||m) &#123;</span><br><span class="line">        <span class="type">int</span> type = <span class="number">0</span>, t;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="type">char</span> c[<span class="number">5</span>];</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            <span class="type">int</span> a = c[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>, b = c[<span class="number">2</span>] - <span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">            <span class="keyword">if</span>(!type) &#123;</span><br><span class="line">                g[a][b] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">floyd</span>();</span><br><span class="line">                type = <span class="built_in">check</span>();</span><br><span class="line">                t = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!type) <span class="built_in">puts</span>(<span class="string">&quot;Sorted sequence cannot be determined.&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;Inconsistency found after %d relations.\n&quot;</span>, t);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Sorted sequence determined after %d relations: &quot;</span>, t);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">get_min</span>());</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/1473/">牛奶工厂</a>  <code>传递闭包</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)&#123;</span><br><span class="line">        g[b<span class="number">-1</span>][a<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span>(!g[i][j]) g[i][j] = g[i][k] &amp; g[k][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> is = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] != <span class="number">1</span>)&#123;</span><br><span class="line">                is = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(is) &#123;</span><br><span class="line">            cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/4247/">牛的比赛 </a> <code>传递闭包</code></p>
<p><strong>如果当前奶牛与其他奶牛的关系都能确定，就可以确定该奶牛所处的位置</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a<span class="number">-1</span>][b<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span>(!g[i][j]) g[i][j] = g[i][k] &amp; g[k][j];</span><br><span class="line">               </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] || g[j][i]) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/346/">观光之旅 </a> <code>最小环问题</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>,INF =<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> g[N][N],d[N][N];</span><br><span class="line"><span class="type">int</span> pos[N][N];</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_path</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> k = pos[i][j];</span><br><span class="line">    <span class="built_in">get_path</span>(i, k);</span><br><span class="line">    path[cnt ++] = k;</span><br><span class="line">    <span class="built_in">get_path</span>(k, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) g[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=INF;</span><br><span class="line">    <span class="built_in">memcpy</span>(d,g,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="comment">// floyd 是典型的插点算法，在每次插点前计算环的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line">        <span class="comment">// 此时i与j之间插入的点可能是1~k-1的任意一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;<span class="built_in">j</span>&lt;k;j++)</span><br><span class="line">                <span class="keyword">if</span>(res &gt; (<span class="type">long</span> <span class="type">long</span>)d[i][j] + g[i][k] + g[k][j]) &#123;</span><br><span class="line">                    res = d[i][j] + g[i][k] + g[k][j];</span><br><span class="line">                    cnt=<span class="number">0</span>;</span><br><span class="line">                    </span><br><span class="line">                    path[cnt ++] = i;  <span class="comment">// 从k走到i(k固定的)</span></span><br><span class="line">                    <span class="built_in">get_path</span>(i ,j);  <span class="comment">// 递归求i到j的路径</span></span><br><span class="line">                    path[cnt ++] = j;  <span class="comment">// j到k, k固定</span></span><br><span class="line">                    path[cnt ++] = k;  <span class="comment">// 先把k放进去</span></span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(d[i][j] &gt; d[i][k] + d[k][j]) &#123;</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">                    pos[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res == INF)  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No solution.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">            cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><a href="https://www.luogu.com.cn/problem/P6175">无向图的最小环问题</a>  <code>最小环问题</code><br><code>floyd</code>是典型的插点算法，所以在第一层循环枚举k的时候，<code>d[i][j]</code> 代表从<code>i</code>到<code>j</code>通过前<code>k-1</code>个节点的最短路径，所以可以形成一个环：<code>i ---- k --- j ---- i</code> ，此时环的边权和为<code>d[i][j] + g[i][k] + g[k][j]</code>，其中<code>i</code>到<code>j</code>之间的节点数并不确定，不断进行枚举就可以选出所有情况，再求最小值即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N], d[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = INF;</span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; k; j++) </span><br><span class="line">                res = <span class="built_in">min</span>(res, (ll)d[i][j] + g[i][k] + g[k][j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res == INF) <span class="built_in">puts</span>(<span class="string">&quot;No solution.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P2886">牛站</a> <code>DP</code>  <code>快速幂</code>  <code>重点</code></p>
<p><a href="https://www.acwing.com/solution/content/199745/">题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N]; </span><br><span class="line"><span class="type">int</span> m,n,K,S,E;</span><br><span class="line"><span class="type">int</span> res[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> r[][N], <span class="type">int</span> x[][N], <span class="type">int</span> y[][N])</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> temp[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> temp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                temp[i][j] = <span class="built_in">min</span>(temp[i][j], x[i][k] + y[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(r, temp, <span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; K &gt;&gt; m &gt;&gt; S &gt;&gt; E;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ids;</span><br><span class="line">    ids[S] = ++ n; ids[E] = ++ n;</span><br><span class="line">    S = ids[S]; E = ids[E];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g); <span class="comment">// 初始数组初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(!ids.<span class="built_in">count</span>(a)) ids[a]=++n;</span><br><span class="line">        <span class="keyword">if</span>(!ids.<span class="built_in">count</span>(b)) ids[b]=++n;</span><br><span class="line">        a = ids[a], b = ids[b];</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> res); <span class="comment">// 结果数组初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(K) &#123;</span><br><span class="line">        <span class="keyword">if</span>(K &amp; <span class="number">1</span>) <span class="built_in">mul</span>(res, res, g);</span><br><span class="line">        <span class="built_in">mul</span>(g, g, g);</span><br><span class="line">        K &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res[S][E];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>c/c++编译过程</title>
    <url>/2023/08/12/c-c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简单编译原理"><a href="#简单编译原理" class="headerlink" title="简单编译原理"></a>简单编译原理</h1><hr>
<h2 id="1-编译过程"><a href="#1-编译过程" class="headerlink" title="1 编译过程"></a>1 编译过程</h2><p>hello 程序的生命周期从一个高级 C 语言程序开始</p>
<p>为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令</p>
<p>然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来</p>
<p>GCC 编译器读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程可分为四个阶段完成，如下图所示</p>
<p>执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilation system）</p>
<hr>
<h3 id="1-1-预处理阶段"><a href="#1-1-预处理阶段" class="headerlink" title="1.1 预处理阶段"></a>1.1 预处理阶段</h3><p><code>预处理器（cpp）</code>根据以字符#开头的命令，修改原始的 C 程序。比如 hello.c中第 1行的 <code>#include &lt;stdio.h&gt;</code> 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 <code>.i</code> 作为文件扩展名</p>
<hr>
<h3 id="1-2-编译阶段"><a href="#1-2-编译阶段" class="headerlink" title="1.2 编译阶段"></a>1.2 编译阶段</h3><p><code>编译器（ccl）</code>将文本文件<code>hello.i</code>翻译成文本文件 <code>hello.s</code>，它包含一<br>个汇编语言程序。每条语句都以一种文本格式描述了一条低级机器语言指令。</p>
<hr>
<h3 id="1-3-汇编阶段"><a href="#1-3-汇编阶段" class="headerlink" title="1.3 汇编阶段"></a>1.3 汇编阶段</h3><p><code>汇编器（as）</code>将 <code>hello.s</code> 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 <code>hello.o</code>中。</p>
<p><code>hello.o</code>文件是一个二进制文件，它包含的17 个字节是函数 main的指令编码。如果我们在文本编辑器中打开 <code>hello.o</code>文件，将看到一堆乱码。</p>
<hr>
<h3 id="1-4-链接阶段"><a href="#1-4-链接阶段" class="headerlink" title="1.4 链接阶段"></a>1.4 链接阶段</h3><p>注意，<code>hello</code>程序调用了 <code>printf</code> 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。<code>printf</code>函数存在于一个名为 <code>printf.o</code> 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 <code>hello.o</code> 程序中。</p>
<p><code>链接器（ld）</code>就负责处理这种合并。结果就得到 <code>hello</code> 文件，它是一个<strong>可执行目标文件（或者简称为可执行文件）</strong>，可以被加载到内存中，由系统执行。</p>
<hr>
<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a><strong>C语言</strong></h1><h2 id="1-Compiling-C"><a href="#1-Compiling-C" class="headerlink" title="1 Compiling C"></a>1 Compiling C</h2><h3 id="1-1-Preprocessing"><a href="#1-1-Preprocessing" class="headerlink" title="1.1 Preprocessing"></a>1.1 Preprocessing</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不会生成 .i 文件</span><br><span class="line">gcc -E main.c</span><br><span class="line">gcc -E main.c -o helloworld.i</span><br></pre></td></tr></table></figure>
<ul>
<li>-E 选项告诉编译器只进行预处理操作</li>
<li>-o 选项把预处理的结果输出到指定文件</li>
</ul>
<h3 id="1-2-Generating-Assembly-Language"><a href="#1-2-Generating-Assembly-Language" class="headerlink" title="1.2 Generating Assembly Language"></a>1.2 Generating Assembly Language</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -S main.c</span><br><span class="line">gcc -S main.c -o xxx.s</span><br></pre></td></tr></table></figure>
<ul>
<li>-S 选项告诉编译器，进行预处理和编译成汇编语言操作</li>
</ul>
<h3 id="1-3-Source-File-to-Object-File"><a href="#1-3-Source-File-to-Object-File" class="headerlink" title="1.3 Source File to Object File"></a>1.3 Source File to Object File</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c main.c</span><br><span class="line">gcc -c main.c -o xxx.o</span><br><span class="line"># 编译多个 .c 文件</span><br><span class="line">gcc -c main.c add.c minus.c</span><br></pre></td></tr></table></figure>
<h3 id="1-4-Single-Source-to-Executable"><a href="#1-4-Single-Source-to-Executable" class="headerlink" title="1.4 Single Source to Executable"></a>1.4 Single Source to Executable</h3><ul>
<li>注意：后面三个命令执行后并没有按编译过程出现 .i .s 或 .o 文件，并不意味着没有经历这些过程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.c</span><br><span class="line">gcc main.c -o xxx</span><br></pre></td></tr></table></figure>
<p>执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./可执行文件</span><br></pre></td></tr></table></figure>
<h3 id="1-5-Multiple-Sources-to-Executable"><a href="#1-5-Multiple-Sources-to-Executable" class="headerlink" title="1.5 Multiple Sources to Executable"></a>1.5 Multiple Sources to Executable</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.c add.c minus.c -o exec</span><br><span class="line">./exec</span><br></pre></td></tr></table></figure>
<h2 id="2-Creating-a-Static-Library"><a href="#2-Creating-a-Static-Library" class="headerlink" title="2 Creating a Static Library"></a>2 Creating a Static Library</h2><ul>
<li><p>编译成 .o 的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c [.c] -o [自定义文件名] </span><br><span class="line">gcc -c [.c] [.c] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>编静态库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ar -r [lib自定义库名.a] [.o] [.o] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接成可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc [.c] [.a] -o [自定义输出文件名]</span><br><span class="line">gcc [.c] -o [自定义输出文件名] -l[库名] -L[库所在路径]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Creating-a-Shared-Library"><a href="#3-Creating-a-Shared-Library" class="headerlink" title="3 Creating a Shared Library"></a>3 Creating a Shared Library</h2><ul>
<li>编译二进制.o文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c -fpic [.c/.cpp][.c/.cpp]... </span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>编库</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -shared [.o][.o]... -o [lib自定义库名.so]</span><br></pre></td></tr></table></figure>
<ul>
<li>链接库到可执行文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc [.c/.cpp] -o [自定义可执行文件名]  -l[库名] -L[库路径] -Wl,-rpath=[库路径]</span><br></pre></td></tr></table></figure>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><h3 id="1-编译过程-1"><a href="#1-编译过程-1" class="headerlink" title="1 编译过程"></a>1 编译过程</h3><p>源文件.c文件 -&gt; 预编译成.i文件 -&gt; 编译成汇编语言.s -&gt; 汇编成.o文件 -&gt; 链接成可执行文件（名字自定义，后缀没关系）</p>
<h3 id="2-编译过程命令"><a href="#2-编译过程命令" class="headerlink" title="2 编译过程命令"></a>2 编译过程命令</h3><ul>
<li><p>预处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -E [.c源文件] -o [自定义输出文件名.i]</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译成汇编语言(隐藏了预处理操作) :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -S [.c源文件] </span><br></pre></td></tr></table></figure>
</li>
<li><p>会变成.o的object文件（二进制文件，可用于链接） :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c [.c源文件] [.c源文件] [...] (可选选项：-o [自定文件名])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-库"><a href="#3-库" class="headerlink" title="3 库"></a>3 库</h3><blockquote>
<p><strong><code>静态库</code></strong></p>
</blockquote>
<ul>
<li><p>编库（先转成.o文件，再编成lib[自定库名].a）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c [.c源文件] [.c源文件] [...] (可选选项：-o [自定文件名])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ar -r lib[自定库名].a [.o文件] [.o文件] [...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc [main文件] -o [自定义输出可执行文件名] -l[库名] -L[库的路径]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong><code>动态库</code></strong></p>
</blockquote>
<ul>
<li><p>编库</p>
<ul>
<li><p>第一种做法， 先转成.o文件，再编成.so文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c -fpic [.c源文件] [.c源文件] [...]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -shared [.o文件] [.o文件] [...] -o lib[库名].so</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种做法，直接转成.so</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -fpic -shared [.c源文件] [.c源文件] [...] -o lib[库名].so</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc [main文件] -o [自定义输出可执行文件名] -l[库名] -L[库所在路径] -Wl,-rpath=[库所在路径]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="1-Compiling-C-1"><a href="#1-Compiling-C-1" class="headerlink" title="1 Compiling C++"></a>1 Compiling C++</h2><h3 id="1-1-Preprocessing-1"><a href="#1-1-Preprocessing-1" class="headerlink" title="1.1 Preprocessing"></a>1.1 Preprocessing</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -E helloworld.c</span><br><span class="line">g++ -E helloworld.c -o helloworld.i</span><br></pre></td></tr></table></figure>
<ul>
<li>-E 选项告诉编译器只进行预处理操作</li>
<li>-o 选项把预处理的结果输出到指定文件      </li>
</ul>
<h3 id="1-2-Generating-Assembly-Language-1"><a href="#1-2-Generating-Assembly-Language-1" class="headerlink" title="1.2 Generating Assembly Language"></a>1.2 Generating Assembly Language</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -S helloworld.c</span><br><span class="line">g++ -S helloworld.c -o helloworld.s</span><br></pre></td></tr></table></figure>
<ul>
<li>-S 选项告诉编译器，进行预处理和编译成汇编语言操作</li>
</ul>
<p>&emsp;</p>
<h3 id="1-3-Source-File-to-Object-File-1"><a href="#1-3-Source-File-to-Object-File-1" class="headerlink" title="1.3 Source File to Object File"></a>1.3 Source File to Object File</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c helloworld.c</span><br><span class="line">g++ -c helloworld.c -o harumph.o</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译多个 .c 文件</span></span><br><span class="line">g++ -c helloworld.c helloworld1.c helloworld2.c</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h3 id="1-4-Single-Source-to-Executable-1"><a href="#1-4-Single-Source-to-Executable-1" class="headerlink" title="1.4 Single Source to Executable"></a>1.4 Single Source to Executable</h3><ul>
<li>注意：后面三个命令执行后并没有按编译过程出现 .i .s 或 .o 文件，并不意味着没有经历这些过程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ helloworld.c</span><br><span class="line">g++ helloworld.c -o howdy</span><br></pre></td></tr></table></figure>
<p>执行程序<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./可执行文件</span><br></pre></td></tr></table></figure></p>
<p>&emsp;</p>
<h3 id="1-5-Mltiple-Source-to-Executable"><a href="#1-5-Mltiple-Source-to-Executable" class="headerlink" title="1.5 Mltiple Source to Executable"></a>1.5 Mltiple Source to Executable</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ hellomain.c sayhello.c -o hello</span><br></pre></td></tr></table></figure>
<p>&emsp;</p>
<h2 id="2-Creating-a-Static-Library-1"><a href="#2-Creating-a-Static-Library-1" class="headerlink" title="2 Creating a Static Library"></a>2 Creating a Static Library</h2><ul>
<li>编译成 .o 的文件  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c [.c] -o [自定义文件名] </span><br><span class="line">g++ -c [.c] [.c] ...</span><br></pre></td></tr></table></figure></li>
<li>编静态库  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar -r [lib自定义库名.a] [.o] [.o] ...</span><br></pre></td></tr></table></figure></li>
<li>链接成可执行文件  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ [.c] [.a] -o [自定义输出文件名]</span><br><span class="line">g++ [.c] -o [自定义输出文件名] -l[库名] -L[库所在路径]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;</p>
<h2 id="3-Creating-a-Shared-Library-1"><a href="#3-Creating-a-Shared-Library-1" class="headerlink" title="3 Creating a Shared Library"></a>3 Creating a Shared Library</h2><ul>
<li>编译二进制.o文件  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c -fpic [.c/.cpp][.c/.cpp]... </span><br></pre></td></tr></table></figure></li>
<li>编库  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -shared [.o][.o]... -o [lib自定义库名.so]</span><br></pre></td></tr></table></figure></li>
<li>连接动态库到可执行文件  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ [.c/.cpp] -o [自定义可执行文件名]  -l[库名] -L[库路径] -Wl,-rpath=[库路径]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;</p>
<h2 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4 总结"></a>4 总结</h2><h3 id="1-编译过程-2"><a href="#1-编译过程-2" class="headerlink" title="1 编译过程"></a>1 编译过程</h3><p>源文件.c文件 -&gt; 预编译成.i文件 -&gt; 编译成汇编语言.s -&gt; 汇编成.o文件 -&gt; 链接成可执行文件（名字自定义，后缀没关系）</p>
<h3 id="2-编译过程命令-1"><a href="#2-编译过程命令-1" class="headerlink" title="2 编译过程命令"></a>2 编译过程命令</h3><ul>
<li>预处理：   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -E [.c源文件] -o [自定义输出文件名.i]</span><br></pre></td></tr></table></figure></li>
<li>编译成汇编语言(隐藏了预处理操作) :  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -S [.c源文件] </span><br></pre></td></tr></table></figure></li>
<li>会变成.o的object文件（二进制文件，可用于链接） :  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -c [.c源文件] [.c源文件] [...] (可选选项：-o [自定文件名])</span><br></pre></td></tr></table></figure>
<h3 id="3-库-1"><a href="#3-库-1" class="headerlink" title="3 库"></a>3 库</h3><blockquote>
<p>静态库</p>
</blockquote>
</li>
<li>编库（先转成.o文件，再编成lib[自定库名].a）  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -c [.c源文件] [.c源文件] [...] (可选选项：-o [自定文件名])</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ar -r lib[自定库名].a [.o文件] [.o文件] [...]</span><br></pre></td></tr></table></figure></li>
<li>链接  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ [main文件] -o [自定义输出可执行文件名] -l[库名] -L[库的路径]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态库</p>
<ul>
<li>编库      <ul>
<li>第一种做法， 先转成.o文件，再编成.so文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c -fpic [.c源文件] [.c源文件] [...]</span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -shared [.o文件] [.o文件] [...] -o lib[库名].so</span><br></pre></td></tr></table></figure></li>
<li>第二种做法，直接转成.so <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -fpic -shared [.c源文件] [.c源文件] [...] -o lib[库名].so</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>链接</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ [main文件] -o [自定义输出可执行文件名] -l[库名] -L[库所在路径] -Wl,-rpath=[库所在路径]</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>经典题型</title>
    <url>/2023/08/14/%E7%BB%8F%E5%85%B8%E9%A2%98%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-括号序列"><a href="#1-括号序列" class="headerlink" title="1 括号序列"></a>1 括号序列</h1><h2 id="1-1-常用知识点"><a href="#1-1-常用知识点" class="headerlink" title="1.1 常用知识点"></a>1.1 常用知识点</h2><ol>
<li><p>平衡括号字符串 (当满足下述条件时)</p>
<ul>
<li><p>字符串仅由 <code>(</code> 和 <code>)</code> 组成。</p>
</li>
<li><p>字符串所包含的 <code>(</code> 和 <code>)</code> 的数量相同。</p>
</li>
<li>对于字符串的任意前缀，其所包含的 <code>(</code> 的数量都不少于 <code>)</code> 的数量。</li>
</ul>
</li>
</ol>
<h2 id="1-2-常见题型"><a href="#1-2-常见题型" class="headerlink" title="1.2 常见题型"></a>1.2 常见题型</h2><ol>
<li><p><a href="https://www.acwing.com/problem/content/5139/">平衡括号字符串</a> <code>贪心</code> </p>
<p>根据题意可得，先将所有的#换成一个<code>)</code>，然后需要满足平衡括号字符串的三个条件，所以需要考虑哪些<code>#</code>可以换成多个<code>)</code>，通过贪心思想很容易进行分析：如果使字符串前面的#换成多个<code>)</code>，可能会因为<code>)</code>数量的增多使后续的前缀字符串不满足条件，所以将需要增加的全部放在最后一个<code>)</code>上即可，然后再验证是否符合题目给出的判断条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line"><span class="type">int</span> ans[N]; <span class="comment">// 记录每个#号变换的&#x27;)&#x27;数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="type">bool</span> is = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="type">char</span> x = str[i];</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;(&#x27;</span>) t++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="string">&#x27;)&#x27;</span>) t--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[cnt ++] = <span class="number">1</span>;</span><br><span class="line">            t --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[cnt - <span class="number">1</span>] += t; <span class="comment">// 剩下的所需要的&#x27;)&#x27;数量加在最后一个#上面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行判断</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> x = str[i];</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;(&#x27;</span>) t++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="string">&#x27;)&#x27;</span>) t--;</span><br><span class="line">        <span class="keyword">else</span> t -= ans[j ++];</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            is = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!is) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>经典题型</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces</title>
    <url>/2023/08/14/codeforces/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Codeforces-Round-892-Div-2"><a href="#Codeforces-Round-892-Div-2" class="headerlink" title="Codeforces Round 892 (Div. 2)"></a><a href="https://codeforces.com/contest/1859">Codeforces Round 892 (Div. 2)</a></h2><ol>
<li><p><a href="https://codeforces.com/contest/1859/problem/A">A - United We Stand</a></p>
<p>根据题意得知，存在三个序列<code>a,b,c</code>，需要对a中的数据进行分配，导致<code>c</code>中的数据和<code>b</code>中的数据两两之间不存在$c|b$  (即不存在<code>b</code>的数据能整除<code>c</code>的数据)，不能满足<code>b = k*c (k是自然数)</code>，因此我们只需要将最小大数据分配到<code>b</code>序列就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] == a[n<span class="number">-1</span>]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tt = <span class="number">0</span>, x = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(a[tt] == x) tt ++; <span class="comment">// 分配给b数组的数据的最后下标</span></span><br><span class="line">    cout &lt;&lt; tt &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n - tt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tt; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = tt; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;t; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://codeforces.com/contest/1859/problem/B">B - Olya and Game with Arrays</a></p>
<p>根据题意可得，此题是需要维护每个数组的最小值和第二小值即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25000</span>, INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;                                                                                                                                 </span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">        vector&lt;ll&gt; V1; <span class="comment">// 存储倒数第二小的值</span></span><br><span class="line">        ll mm = INF; ll aa = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> m;  ll minv1 = INF, minv2 = INF;</span><br><span class="line">            cin&gt;&gt;m;</span><br><span class="line">            <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">                ll x; cin&gt;&gt;x;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; minv1) &#123;</span><br><span class="line">                    ll temp = minv1;</span><br><span class="line">                    minv1 = x; minv2 = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &gt;= minv1 &amp;&amp; x &lt;= minv2) &#123;</span><br><span class="line">                    minv2 =x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mm = <span class="built_in">min</span>(mm, minv1); V1.<span class="built_in">push_back</span>(minv2);</span><br><span class="line">            aa += minv1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(V1.<span class="built_in">begin</span>(), V1.<span class="built_in">end</span>());</span><br><span class="line">        ll ans = mm;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; V1.<span class="built_in">size</span>();i++) ans += V1[i];</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(ans, aa) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Educational-Codeforces-Round-153-Rated-for-Div-2"><a href="#Educational-Codeforces-Round-153-Rated-for-Div-2" class="headerlink" title="Educational Codeforces Round 153 (Rated for Div. 2)"></a><a href="https://codeforces.com/contest/1860">Educational Codeforces Round 153 (Rated for Div. 2)</a></h1><ol>
<li><p><a href="https://codeforces.com/contest/1860/problem/A">Not a Substring</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="string">&quot;()&quot;</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">	<span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">bool</span> is = <span class="literal">true</span>; <span class="comment">// 是否是左右括号交替出现的情况</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == s[i - <span class="number">1</span>]) is = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(is) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">string</span>(n, <span class="string">&#x27;(&#x27;</span>) + <span class="built_in">string</span>(n, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;()&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://codeforces.com/contest/1860/problem/B">B - Fancy Coins</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m,k,a,b;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;k&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="type">int</span> mk = m % k; <span class="comment">// 最多需要1元硬币的数量</span></span><br><span class="line">	<span class="type">int</span> m_k = m / k; <span class="comment">// 最多需要k元硬币的数量</span></span><br><span class="line">	<span class="keyword">if</span>(a &gt;= mk) &#123;</span><br><span class="line">		a -= mk;</span><br><span class="line">		b += a / k; <span class="comment">// 将剩下的一元硬币转换为k元的</span></span><br><span class="line">		cout &lt;&lt; <span class="built_in">max</span>(<span class="number">0</span>, m_k - b)&lt;&lt; endl;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">max</span>(<span class="number">0</span>, m_k - b) + mk - a &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://codeforces.com/contest/1860/problem/C">Game on Permutation</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="type">int</span> min_ac = <span class="number">1e9</span>, mi = a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &gt; mi &amp;&amp; a[i] &lt; min_ac) &#123;</span><br><span class="line">			min_ac = <span class="built_in">min</span>(min_ac, a[i]);</span><br><span class="line">			ans ++;</span><br><span class="line">		&#125;</span><br><span class="line">		mi = <span class="built_in">min</span>(mi, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codeforces.com/contest/1879/problem/C">Make it Alternating</a> <code>模拟</code></p>
<p>假设需要删除<code>n</code>个字符串，根据题意可得公有<code>n!</code>种方法，又根据每个字符串都有<code>m</code>个数，所以结果移动位所有的<code>m</code>个数相乘再乘以<code>n!</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="comment">// 将所有连续的数字分成一个个小块</span></span><br><span class="line"><span class="comment">// 然后每个小块可以选择len次</span></span><br><span class="line"><span class="comment">// 然后小块的顺序为，小块个数的阶乘</span></span><br><span class="line"><span class="comment">// 所以第二问的结果为 每个小块的总次数 * 阶乘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s;cin&gt;&gt;s;s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] != s[i<span class="number">-1</span>])&#123;</span><br><span class="line">			sum += (len - <span class="number">1</span>);</span><br><span class="line">			ans = ans * len % mod;</span><br><span class="line">			len = <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> len++;</span><br><span class="line">	&#125;</span><br><span class="line">	sum += len<span class="number">-1</span>;</span><br><span class="line">	ans = ans * len % mod;</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; f[sum] * ans % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N - <span class="number">10</span>; i++) f[i] = f[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">    <span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    	<span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codeforces.com/contest/1879/problem/D">Sum of XOR Functions</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>状压DP</title>
    <url>/2023/08/17/%E7%8A%B6%E5%8E%8BDP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h1><h2 id="1-棋盘式（基于连通性）"><a href="#1-棋盘式（基于连通性）" class="headerlink" title="1 棋盘式（基于连通性）"></a>1 棋盘式（基于连通性）</h2><ol>
<li><p><a href="https://www.luogu.com.cn/problem/P1896">互不侵犯</a></p>
<p>经典的状态压缩问题，使用二进制表示每一行的状态</p>
<ul>
<li><p>状态方程的定义：<code>f[i][j][k]</code>  前<code>i</code>行总共放<code>j</code>个国王，且状态为<code>k</code>时的总方案数</p>
</li>
<li><p>状态方程的转移：假设第<code>i-1</code>行的状态为<code>a</code>，第<code>i</code>行的状态为<code>b</code>，由题意可得，要进行转移，需要满足</p>
<p><code>a</code>和<code>b</code>的二进制都不存在相邻的<code>1</code>，且<code>a &amp; b == 0</code> 和 <code>a | b</code> 也不存在相邻的1。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, K = N * N;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll f[N][K][<span class="number">1</span> &lt;&lt; N]; <span class="comment">// f[i][j][k] 前i行，j个国王，且状态为k时的总方案数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断每个状态是否不含有相邻的1</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">if</span>(x &gt;&gt; i &amp; <span class="number">1</span> &amp;&amp; x &gt;&gt; i - <span class="number">1</span> &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) &#123;</span><br><span class="line">		<span class="keyword">if</span>(x &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">		x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">1</span> &lt;&lt; n; a++)</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check</span>(a)) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">1</span> &lt;&lt; n; b++)</span><br><span class="line">						<span class="keyword">if</span>((a &amp; b) == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(a | b)) &#123;</span><br><span class="line">							<span class="type">int</span> num = <span class="built_in">get_count</span>(a);</span><br><span class="line">							<span class="keyword">if</span>(j &gt;= num) f[i][j][a] += f[i - <span class="number">1</span>][j - num][b];</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">	cout &lt;&lt; f[n + <span class="number">1</span>][m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/329/">玉米田</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">14</span>, mod = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; pre;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tar[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span>(x &gt;&gt; i &amp; <span class="number">1</span> &amp;&amp; x &gt;&gt; i - <span class="number">1</span> &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span>) g[i] |= (<span class="number">1</span> &lt;&lt; m - j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++) <span class="comment">// 预处理满足条件的状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i)) pre.<span class="built_in">push_back</span>(i); </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : pre) <span class="comment">// 预处理能够进行状态转移的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : pre)</span><br><span class="line">            <span class="keyword">if</span>((i &amp; j) == <span class="number">0</span>) tar[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">            </span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : pre)</span><br><span class="line">            <span class="keyword">if</span>(!(g[i - <span class="number">1</span>] &amp; j)) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> k : tar[j])</span><br><span class="line">                    f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; f[n + <span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.acwing.com/problem/content/description/294/">炮兵阵地</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][M][M]; <span class="comment">// f[i][j][k] 前i行第i行的状态为j，且第i-1行的状态为k时最多能放置的炮的数量</span></span><br><span class="line"><span class="type">int</span> cnt[M]; <span class="comment">// 存储每个状态的炮台个数</span></span><br><span class="line"><span class="type">int</span> g[N]; <span class="comment">// 山地</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; status; <span class="comment">// 预处理能用的状态</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; mapping[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">// 判断是否含有相邻的1</span></span><br><span class="line">    <span class="keyword">return</span> !(x &amp; x &gt;&gt; <span class="number">1</span> || x &amp; x &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_cnt</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) c ++;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="type">char</span> c; cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;H&#x27;</span>) g[i] |= <span class="number">1</span> &lt;&lt; (m - j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">            status.<span class="built_in">push_back</span>(i);</span><br><span class="line">            cnt[i] = <span class="built_in">get_cnt</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : status) <span class="comment">// i行状态</span></span><br><span class="line">            <span class="keyword">if</span>(!(g[i] &amp; a)) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> b : status) <span class="comment">// i - 1</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> c : status) &#123;</span><br><span class="line">                            <span class="keyword">if</span>((a &amp; b) == <span class="number">0</span> &amp;&amp; (a &amp; c) == <span class="number">0</span>) &#123;</span><br><span class="line">                                f[i &amp; <span class="number">1</span>][a][b] = <span class="built_in">max</span>(f[i &amp; <span class="number">1</span>][a][b], f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][b][c] + cnt[a]);</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; f[2][0][0] &lt;&lt; endl;     </span></span><br><span class="line">    cout &lt;&lt; f[n + <span class="number">2</span> &amp; <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.cn/problems/maximum-students-taking-exam/description/">参加考试的最大学生数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// f[i][j] 前i行，且第i行状态为j的最大学生数量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>( (x &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; (x &gt;&gt; (i - <span class="number">1</span>) &amp; <span class="number">1</span>) ) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxStudents</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = seats.<span class="built_in">size</span>(), m = seats[<span class="number">0</span>].<span class="built_in">size</span>(), INF = <span class="number">1e9</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span>(seats[i][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                  g[i] |= <span class="number">1</span> &lt;&lt; m - j - <span class="number">1</span>; <span class="comment">// 代表每行座位的状态</span></span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span> &lt;&lt; m, -INF));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span>( !( g[i - <span class="number">1</span>] &amp; j ) &amp;&amp; <span class="built_in">check</span>(j)) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; m; k++) </span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">check</span>(j | k)) &#123;</span><br><span class="line">                            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][k] + <span class="built_in">get_count</span>(j));</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++) ans = <span class="built_in">max</span>(ans, f[n][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2 集合"></a>2 集合</h2><ol>
<li></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu</title>
    <url>/2023/08/19/luogu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><p><a href="https://www.luogu.com.cn/problem/P9519?contestId=123900">pay</a> <code>二分</code>  <code>二次差分</code></p>
<p>加入在<code>x</code>点加上<code>k</code>，则使用<code>c[i]</code>来表示结果的差分数组，根据题意可得，<code>x - k + 1 ~ x</code>分别加上 <code>1 ~ k</code>, 所以差分数组在每个点都要加上1；<code>x + 1 ~ x + k</code>分别减上 <code>1 ~ k</code>, 所以差分数组在每个点上都要减一(对结果的差分数组进行一段区间的加1减一操作，可再次使用差分数组对其进行简化，即二次差分)，边界情况需要特殊处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;	</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cl[N], c[N]; <span class="comment">// c 对结果的差分处理 cl 对 c 的差分处理</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cl, <span class="number">0</span>, <span class="keyword">sizeof</span> cl);</span><br><span class="line">	<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> l1 = b[i] - k + <span class="number">1</span>, r1 = b[i], l2 = b[i] + <span class="number">1</span>, r2 = <span class="built_in">min</span>(n, b[i] + k);</span><br><span class="line">		<span class="comment">// l1~r1 +1  l2~r2 -1</span></span><br><span class="line">		<span class="keyword">if</span>(l1 &lt; <span class="number">1</span>) &#123; <span class="comment">// 边界情况特殊处理</span></span><br><span class="line">			c[<span class="number">1</span>] += k - (b[i] - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(r1 &gt;= <span class="number">2</span>) cl[<span class="number">2</span>] ++, cl[r1 + <span class="number">1</span>] --;</span><br><span class="line">		&#125; <span class="keyword">else</span> cl[l1] ++, cl[r1 + <span class="number">1</span>] --;</span><br><span class="line">		<span class="keyword">if</span>(l2 &lt;= r2) cl[l2] --, cl[r2 + <span class="number">1</span>] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cl[i] += cl[i - <span class="number">1</span>]; <span class="comment">// 求点i的差分</span></span><br><span class="line">		c[i] += c[i - <span class="number">1</span>] + cl[i]; <span class="comment">// 求点i的具体数值</span></span><br><span class="line">		<span class="keyword">if</span>(c[i] &lt; a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cin &gt;&gt; b[i];</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e12</span>;</span><br><span class="line">	<span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">		<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/2023/09/07/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-普通快速幂"><a href="#1-普通快速幂" class="headerlink" title="1.普通快速幂"></a>1.普通快速幂</h1><hr>
<h1 id="2-矩阵快速幂"><a href="#2-矩阵快速幂" class="headerlink" title="2.矩阵快速幂"></a>2.矩阵快速幂</h1><h2 id="1-原理即写法"><a href="#1-原理即写法" class="headerlink" title="1.原理即写法"></a>1.原理即写法</h2><hr>
<h2 id="2-常见题型"><a href="#2-常见题型" class="headerlink" title="2.常见题型"></a>2.常见题型</h2><h3 id="1-随机数生成器-矩阵快速幂-构造矩阵-慢速乘法"><a href="#1-随机数生成器-矩阵快速幂-构造矩阵-慢速乘法" class="headerlink" title="1.随机数生成器 矩阵快速幂 构造矩阵 慢速乘法"></a>1.<a href="https://www.luogu.com.cn/problem/P2044">随机数生成器</a> <code>矩阵快速幂</code> <code>构造矩阵</code> <code>慢速乘法</code></h3><p>首先根据题意推导出矩阵表达式，使用矩阵快速幂进行求解，不过不能<code>AC</code>，因为数据过大，会超过long long的大小限制，所以采取对普通乘法进行降速处理，即通过类似于求快速幂的方法，来使用快速加法来代替乘法，从而在加法的每一步中进行取模，减少溢出的可能性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line">ll m, a, c, X0, n, g;</span><br><span class="line"><span class="function">ll <span class="title">slow_mul</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(y) &#123;</span><br><span class="line">		<span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = (ans + x) % m;</span><br><span class="line">		x = (x + x) % m;</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">martix</span> &#123;</span><br><span class="line">	ll x[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">	<span class="built_in">martix</span>() &#123; <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span> x); &#125;</span><br><span class="line">	martix <span class="keyword">operator</span>*(<span class="type">const</span> martix &amp;p) <span class="type">const</span> &#123;</span><br><span class="line">		martix ans;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++)</span><br><span class="line">					ans.x[i][j] = (ans.x[i][j] + <span class="built_in">slow_mul</span>(x[i][k], p.x[k][j]) ) % m;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;base, ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	base.x[<span class="number">1</span>][<span class="number">1</span>] = a, base.x[<span class="number">1</span>][<span class="number">2</span>] = base.x[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	ans.x[<span class="number">1</span>][<span class="number">1</span>] = X0, ans.x[<span class="number">2</span>][<span class="number">1</span>] = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mpow</span><span class="params">(ll a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(a) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a &amp; <span class="number">1</span>) ans = base * ans;</span><br><span class="line">		base = base * base;</span><br><span class="line">		a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;a&gt;&gt;c&gt;&gt;X0&gt;&gt;n&gt;&gt;g;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">mpow</span>(n);</span><br><span class="line">	cout &lt;&lt; ans.x[<span class="number">1</span>][<span class="number">1</span>] % g &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Cow-Relays-G-最短路-矩阵转换-类Floyd"><a href="#2-Cow-Relays-G-最短路-矩阵转换-类Floyd" class="headerlink" title="2.Cow Relays G  最短路 矩阵转换 类Floyd"></a>2.<a href="https://www.luogu.com.cn/problem/P2886">Cow Relays G</a>  <code>最短路</code> <code>矩阵转换</code> <code>类Floyd</code></h3><p>前置知识：</p>
<ol>
<li>我们通过邻接矩阵存储图(0: 代表无边，1：代表有边)，所以，初始状态的邻接矩阵的意义是代表两点之间经过一条边的路径数。设矩阵<em>A</em>表示经过<em>k</em>1条边的路径数，<em>B</em>表示经过<em>k</em>2条边的路径数，则<em>A</em>∗<em>B</em>表示经过(<em>k</em>1+<em>k</em>2)条边的路径数。</li>
<li>本题要求的是最短路，所以把乘法改成加法再求最小值即可。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t, S, E, cnt;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ids;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">martix</span> &#123;</span><br><span class="line">	<span class="type">int</span> x[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line">	<span class="built_in">martix</span>() &#123;<span class="built_in">memset</span>(x, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> x);&#125;</span><br><span class="line">	martix <span class="keyword">operator</span>*(<span class="type">const</span> martix &amp;m) <span class="type">const</span> &#123;</span><br><span class="line">		martix ans;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=cnt;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)</span><br><span class="line">                    ans.x[i][j] = <span class="built_in">min</span>(ans.x[i][j], x[i][k] + m.x[k][j]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;ans, base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mpow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n--;</span><br><span class="line">	ans = base;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans = ans * base;</span><br><span class="line">		base = base * base;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;t&gt;&gt;S&gt;&gt;E;</span><br><span class="line">	ids[S] = ++cnt, ids[E] = ++cnt;</span><br><span class="line">	S = ids[S], E = ids[E];</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="type">int</span> w,u,v;</span><br><span class="line">		cin &gt;&gt; w &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		<span class="keyword">if</span>(!ids.<span class="built_in">count</span>(u)) </span><br><span class="line">			ids[u] = ++cnt;</span><br><span class="line">		<span class="keyword">if</span>(!ids.<span class="built_in">count</span>(v))</span><br><span class="line">			ids[v] = ++cnt;</span><br><span class="line">		u = ids[u], v = ids[v];</span><br><span class="line">		base.x[u][v] = base.x[v][u] = <span class="built_in">min</span>(base.x[u][v], w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mpow</span>();</span><br><span class="line">	cout &lt;&lt; ans.x[S][E];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-字符串转换-kmp-矩阵快速幂-状态机模型"><a href="#3-字符串转换-kmp-矩阵快速幂-状态机模型" class="headerlink" title="3.字符串转换 kmp 矩阵快速幂 状态机模型"></a>3.<a href="https://leetcode.cn/problems/string-transformation/">字符串转换</a> <code>kmp</code> <code>矩阵快速幂</code> <code>状态机模型</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">martix</span> &#123;</span><br><span class="line">        ll x[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">martix</span>() &#123;<span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span> x);&#125;</span><br><span class="line">        martix <span class="keyword">operator</span>*(<span class="type">const</span> martix &amp;m) <span class="type">const</span> &#123;</span><br><span class="line">            martix ans;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                        ans.x[i][j] += m.x[i][k] * x[k][j];</span><br><span class="line">                        ans.x[i][j] %= mod;</span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;ans, base;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfWays</span><span class="params">(string s, string t, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l1 = s.<span class="built_in">size</span>(), l2 = t.<span class="built_in">size</span>();</span><br><span class="line">        string ss = s + s.<span class="built_in">substr</span>(<span class="number">0</span>, l1<span class="number">-1</span>); <span class="comment">// 组合后的字符串</span></span><br><span class="line">        <span class="type">int</span> l3 = ss.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 求t在ss上能够完全匹配的个数</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ne</span><span class="params">(l2)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; l2; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; t[i] != t[j]) j = ne[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(t[i] == t[j]) j++;</span><br><span class="line">            ne[i]  = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; l3; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; ss[i] != t[j]) j = ne[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(ss[i] == t[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j == l2) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                j = ne[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            ans.x[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            ans.x[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.x[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            ans.x[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        base.x[<span class="number">1</span>][<span class="number">1</span>] = cnt - <span class="number">1</span>, base.x[<span class="number">1</span>][<span class="number">2</span>] = cnt;</span><br><span class="line">        base.x[<span class="number">2</span>][<span class="number">1</span>] = l1 - cnt, base.x[<span class="number">2</span>][<span class="number">2</span>] = l1 - cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ans = ans * base;</span><br><span class="line">            base = base * base;</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.x[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/2023/08/25/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1-统计特殊整数"><a href="#1-统计特殊整数" class="headerlink" title="1.统计特殊整数"></a>1.<a href="https://leetcode.cn/problems/count-special-integers/description/">统计特殊整数</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: <span class="comment"># 经典数位DP</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSpecialNumbers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="built_in">str</span>(n)  </span><br><span class="line">        <span class="comment"># 返回从i开始填数字，前面填的数字的集合是mask，能构造出整数的数目</span></span><br><span class="line">        <span class="comment"># isLimit 表示前面填的数字是否都是原数字位的上限，如果为True，那么当前位最多为s[i],否则为9</span></span><br><span class="line">        <span class="comment"># isNum 表示前面是否填了数字即是否跳过，如果为True，那么当前位可以从0开始，否则可以进行跳过或者从i开始填数字</span></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, mask: <span class="built_in">int</span>, isLimit: <span class="built_in">bool</span>, isNum: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(isNum)</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isNum:</span><br><span class="line">                res = dfs(i+<span class="number">1</span>, mask, <span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> isLimit <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> <span class="keyword">if</span> isNum <span class="keyword">else</span> <span class="number">1</span>, up+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> mask &gt;&gt; d &amp; <span class="number">1</span> == <span class="number">0</span>: <span class="comment"># 未含有该数字</span></span><br><span class="line">                    res += dfs(i+<span class="number">1</span>, mask | <span class="number">1</span>&lt;&lt;d, isLimit <span class="keyword">and</span> d == up, <span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> s = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), cache[m][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(cache, <span class="number">-1</span>, <span class="keyword">sizeof</span> cache);</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>, <span class="type">bool</span>)&gt; f = [&amp;](<span class="type">int</span> i, <span class="type">int</span> mask, <span class="type">bool</span> is_limit, <span class="type">bool</span> is_num) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == m) <span class="keyword">return</span> is_num;</span><br><span class="line">            <span class="keyword">if</span>(!is_limit &amp;&amp; is_num &amp;&amp; cache[i][mask] != <span class="number">-1</span>) <span class="keyword">return</span> cache[i][mask];</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!is_num) res = <span class="built_in">f</span>(i + <span class="number">1</span>, mask, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="type">int</span> up = is_limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span> - is_num; d &lt;= up; d++) &#123;</span><br><span class="line">                <span class="keyword">if</span>((mask &gt;&gt; d &amp; <span class="number">1</span>) == <span class="number">0</span>) </span><br><span class="line">                    res += <span class="built_in">f</span>(i + <span class="number">1</span>, mask | <span class="number">1</span> &lt;&lt; d, is_limit &amp;&amp; d == up, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cache[i][mask] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-数字1的个数"><a href="#2-数字1的个数" class="headerlink" title="2.数字1的个数"></a>2.<a href="https://leetcode.cn/problems/number-of-digit-one/description/">数字1的个数</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countDigitOne</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="built_in">str</span>(n)</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, cnt: <span class="built_in">int</span>, is_limit: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> cnt</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> is_limit <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(up + <span class="number">1</span>):</span><br><span class="line">                res += f(i + <span class="number">1</span>, cnt + (d == <span class="number">1</span>), is_limit <span class="keyword">and</span> d == up)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-不含连续1的非负整数"><a href="#3-不含连续1的非负整数" class="headerlink" title="3.不含连续1的非负整数"></a>3.<a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/">不含连续1的非负整数</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findIntegers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="built_in">str</span>(<span class="built_in">bin</span>(n))[<span class="number">2</span>:]</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, pre: <span class="built_in">bool</span>, is_limit: <span class="built_in">bool</span></span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> is_limit <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            res = f(i + <span class="number">1</span>, <span class="literal">False</span>, is_limit <span class="keyword">and</span> up == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">and</span> up == <span class="number">1</span>:</span><br><span class="line">                res += f(i + <span class="number">1</span>, <span class="literal">True</span>, is_limit)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-至少有-1-位重复的数字"><a href="#3-至少有-1-位重复的数字" class="headerlink" title="3.至少有 1 位重复的数字"></a>3.<a href="https://leetcode.cn/problems/numbers-with-repeated-digits/">至少有 1 位重复的数字</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numDupDigitsAtMostN</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="built_in">str</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, mask: <span class="built_in">int</span>, is_limit: <span class="built_in">bool</span>, is_num: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(is_num)</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_num:</span><br><span class="line">                res = f(i + <span class="number">1</span>, mask, <span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> is_limit <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> - <span class="built_in">int</span>(is_num), up+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> (mask &gt;&gt; d &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                    res += f(i + <span class="number">1</span>, mask | <span class="number">1</span> &lt;&lt; d, is_limit <span class="keyword">and</span> d == up, <span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> n - f(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-找到所有好字符串-kmp"><a href="#4-找到所有好字符串-kmp" class="headerlink" title="4.找到所有好字符串 kmp"></a>4.<a href="https://leetcode.cn/problems/find-all-good-strings/">找到所有好字符串</a> <code>kmp</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findGoodStrings</span>(<span class="params">self, n: <span class="built_in">int</span>, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span>, evil: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(evil)</span><br><span class="line">        ne = [<span class="number">0</span>] * m</span><br><span class="line">        i = <span class="number">1</span>; j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; m:</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> evil[i] != evil[j]:</span><br><span class="line">                j = ne[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> evil[i] == evil[j]: </span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            ne[i] = j</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        MOD = <span class="built_in">int</span>(<span class="number">1e9</span>+<span class="number">7</span>)</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span>, is_limit: <span class="built_in">bool</span>, upper: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> j == m:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(upper):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            up = upper[i] <span class="keyword">if</span> is_limit <span class="keyword">else</span> <span class="string">&#x27;z&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>, <span class="built_in">ord</span>(up) + <span class="number">1</span>):</span><br><span class="line">                x = <span class="built_in">chr</span>(c)</span><br><span class="line">                nj = j</span><br><span class="line">                <span class="keyword">while</span> nj &gt; <span class="number">0</span> <span class="keyword">and</span> x != evil[nj]:</span><br><span class="line">                    nj = ne[nj - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> x == evil[nj]:</span><br><span class="line">                    nj += <span class="number">1</span></span><br><span class="line">                res += f(i + <span class="number">1</span>, nj, is_limit <span class="keyword">and</span> x == up, upper)</span><br><span class="line">                res %= MOD</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> ( f(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>, s2) - f(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>, s1) + <span class="built_in">int</span>(evil <span class="keyword">not</span> <span class="keyword">in</span> s1) ) % MOD</span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<h3 id="5-HDU2089-不要62-数位DP-记忆化搜索"><a href="#5-HDU2089-不要62-数位DP-记忆化搜索" class="headerlink" title="5.HDU2089 不要62 数位DP  记忆化搜索"></a>5.<strong><a href="https://link.zhihu.com/?target=http%3A//acm.hdu.edu.cn/showproblem.php%3Fpid%3D2089">HDU2089 不要62</a></strong> <code>数位DP</code>  <code>记忆化搜索</code></h3><p>定义函数<code>f(int i, int pre, bool is_limit, string s)</code> ：</p>
<ul>
<li><code>i: 代表当前枚举的是哪一位</code></li>
<li><code>pre: 上一个位所使用的数字，用于对62进行特判</code></li>
<li><code>is_limit: 代表前面的位是否枚举到当前数的上限，如果达到，要对现在操作的位的大小进行限制</code></li>
<li><code>s: 枚举的数的字符串形式</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cache[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> pre, <span class="type">bool</span> is_limit, string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!is_limit &amp;&amp; cache[i][pre] != <span class="number">-1</span>) <span class="keyword">return</span> cache[i][pre];</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> up = is_limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(d == <span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(d == <span class="number">2</span> &amp;&amp; pre == <span class="number">6</span>) <span class="keyword">continue</span>;</span><br><span class="line">		ans += <span class="built_in">f</span>(i + <span class="number">1</span>, d, is_limit &amp;&amp; up == d, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!is_limit) cache[i][pre] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> aa, <span class="type">int</span> bb)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(aa == <span class="number">0</span>) aa += <span class="number">1</span>, cnt = <span class="number">1</span>;</span><br><span class="line">	string a = <span class="built_in">to_string</span>(aa - <span class="number">1</span>);</span><br><span class="line">	string b = <span class="built_in">to_string</span>(bb);</span><br><span class="line">	<span class="built_in">memset</span>(cache, <span class="number">-1</span>, <span class="keyword">sizeof</span> cache);</span><br><span class="line">	<span class="type">int</span> a1 = <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, b);</span><br><span class="line">	<span class="built_in">memset</span>(cache, <span class="number">-1</span>, <span class="keyword">sizeof</span> cache);</span><br><span class="line">	<span class="type">int</span> a2 = <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, a);</span><br><span class="line">	cout &lt;&lt; a1 - a2 + cnt &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b, a || b) &#123;</span><br><span class="line">		<span class="built_in">solve</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-数字计数-数位DP"><a href="#6-数字计数-数位DP" class="headerlink" title="6.数字计数  数位DP"></a>6.<a href="https://www.luogu.com.cn/problem/P2602">数字计数</a>  <code>数位DP</code></h3><p>记录当前所求数字在0~9每个数码出现的次数，进行相减即可。</p>
<p><code>dfs(int i, int cnt, bool limit, bool is_num, string s);</code></p>
<ul>
<li><code>cnt: 记录当前数码的个数。</code></li>
<li><code>limit: 代表前面的位是否枚举到当前数的上限，如果达到，要对现在操作的位的大小进行限制</code>。</li>
<li><code>is_num: 代表前面的位是否填了数字(具体来说，就是是否存在前导0，如果为FALSE，代表前面均是前导0)，如果为true，代表填了数字，可以从0开始进行枚举，如果为false，代表前面未填写数字，此时，后面的枚举可以进行跳过(即继续不填写数字)，或者填写数字，从1开始填写。</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll cache[<span class="number">23</span>][<span class="number">23</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> digit;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cnt, <span class="type">bool</span> limit, <span class="type">bool</span> is_num, string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> is_num ? cnt : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cache[i][cnt][limit][is_num] != <span class="number">-1</span>) <span class="keyword">return</span> cache[i][cnt][limit][is_num];</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!is_num) ans = <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt, <span class="literal">false</span>, <span class="literal">false</span>, s);</span><br><span class="line">    <span class="type">int</span> up = limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span> - is_num; d &lt;= up; d++) &#123;</span><br><span class="line">        ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt + (d == digit), limit &amp;&amp; d == up, <span class="literal">true</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    cache[i][cnt][limit][is_num] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(x);</span><br><span class="line">    <span class="built_in">memset</span>(cache, <span class="number">-1</span>, <span class="keyword">sizeof</span> cache);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b; ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);  cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        digit = i;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">f</span>(b) - <span class="built_in">f</span>(a - <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-Little-Girl-and-Maximum-XOR"><a href="#7-Little-Girl-and-Maximum-XOR" class="headerlink" title="7. Little Girl and Maximum XOR"></a>7.<a href="https://codeforces.com/problemset/problem/276/D"> Little Girl and Maximum XOR</a></h3><p>本题主要作法：</p>
<ul>
<li>将范围<code>[a,b]</code>改成二进制形式</li>
<li>因为异或操作需要两个操作数，所以需要保存两个操作数的信息，即保存两个数是否到达上限和下限</li>
<li><code>dfs(i, x_down, x_up, y_down, y_up)</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">ll A[<span class="number">64</span>], B[<span class="number">64</span>];</span><br><span class="line">ll cnt;</span><br><span class="line">ll dp[<span class="number">64</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">bool</span> x_down, <span class="type">bool</span> x_up, <span class="type">bool</span> y_down, <span class="type">bool</span> y_up)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == cnt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> &amp;d = dp[i][x_down][x_up][y_down][y_up];</span><br><span class="line">	<span class="keyword">if</span>(d != <span class="number">-1</span>) <span class="keyword">return</span> d;</span><br><span class="line">	<span class="keyword">for</span>(ll u = (x_down ? A[i] : <span class="number">0</span>); u &lt;= (x_up ? B[i] : <span class="number">1</span>); u++)</span><br><span class="line">		<span class="keyword">for</span>(ll v = (y_down ? A[i] : <span class="number">0</span>); v &lt;= (y_up ? B[i] : <span class="number">1</span>); v++) &#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, ((u ^ v) &lt;&lt; (cnt - i - <span class="number">1</span>)) + </span><br><span class="line">				<span class="built_in">dfs</span>(i + <span class="number">1</span>, x_down &amp;&amp; u == A[i], x_up &amp;&amp; u == B[i], y_down &amp;&amp; v == A[i], y_up &amp;&amp; v == B[i])</span><br><span class="line">				);</span><br><span class="line">		&#125;</span><br><span class="line">	d = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	ll c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="keyword">while</span>(a) &#123;</span><br><span class="line">		A[c1 ++] = a &amp; <span class="number">1</span>;</span><br><span class="line">		a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		B[c2 ++] = b &amp; <span class="number">1</span>;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt = <span class="built_in">max</span>(c1, c2);</span><br><span class="line">	<span class="built_in">reverse</span>(A, A + cnt);</span><br><span class="line">	<span class="built_in">reverse</span>(B, B + cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	ll a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">f</span>(a, b) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-Bomb"><a href="#8-Bomb" class="headerlink" title="8.Bomb"></a>8.<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3555">Bomb</a></h3><p>经典的数位DP问题</p>
<ul>
<li>方向一：直接选出包含49的数字</li>
<li>方向二：选出不包含49的数字，与总数量相减</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line">ll mem[<span class="number">64</span>][<span class="number">10</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> pre, <span class="type">bool</span> limit, string s, <span class="type">bool</span> is_res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">int</span>(is_res);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mem[i][pre][is_res][limit] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][pre][is_res][limit];</span><br><span class="line">    <span class="type">int</span> up = limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(d == <span class="number">9</span> &amp;&amp; pre == <span class="number">4</span> || is_res) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, d, limit &amp;&amp; up == d, s, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, d, limit &amp;&amp; up == d, s, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mem[i][pre][is_res][limit] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">    string s = <span class="built_in">to_string</span>(n);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, s, <span class="literal">false</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t; cin&gt;&gt;t; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line">ll mem[<span class="number">64</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> pre, <span class="type">bool</span> limit, string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; mem[i][pre] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][pre];</span><br><span class="line">	<span class="type">int</span> up = limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(d == <span class="number">9</span> &amp;&amp; pre == <span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, d, limit &amp;&amp; up == d, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit) mem[i][pre] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	ll m = n;</span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">	string s = <span class="built_in">to_string</span>(n);</span><br><span class="line">	cout &lt;&lt; m - <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, s) + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin&gt;&gt;t; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-windy数"><a href="#9-windy数" class="headerlink" title="9.windy数"></a>9.<a href="https://www.luogu.com.cn/problem/P2657">windy数</a></h3><p>   <code>dfs(i, pre, limit, is_num)</code></p>
<ul>
<li><p>i：代表当前枚举的位的位置</p>
</li>
<li><p>pre：代表当前枚举数的前一位的数字，只有当前数字(d) 与pre满足<code>abs(d - pre) &gt;= 2</code> 才进行处理</p>
</li>
<li><p>limit：是否到达上限</p>
</li>
<li><p>is_num：用于处理前导0</p>
<p><strong>将pre初始化为-1，忽略对第一个数的判断，确保第一个数为1时，也能继续进行枚举</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line">ll mem[<span class="number">11</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> pre,<span class="type">bool</span> limit, <span class="type">bool</span> is_num, string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">ll</span>(is_num);</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num &amp;&amp; mem[s.<span class="built_in">size</span>() - i - <span class="number">1</span>][pre] != <span class="number">-1</span>) <span class="keyword">return</span> mem[s.<span class="built_in">size</span>() - i - <span class="number">1</span>][pre];</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!is_num) ans = <span class="built_in">dfs</span>(i + <span class="number">1</span>, pre, <span class="literal">false</span>, <span class="literal">false</span>, s);</span><br><span class="line">	<span class="type">int</span> up = limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span> - is_num; d &lt;= up; d++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(d - pre) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">			ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, d, limit &amp;&amp; up == d, <span class="literal">true</span>, s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num) mem[s.<span class="built_in">size</span>() - i - <span class="number">1</span>][pre] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m; cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">	string s1 = <span class="built_in">to_string</span>(n - <span class="number">1</span>);</span><br><span class="line">	ll a1 = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="literal">true</span>, <span class="literal">false</span>, s1);</span><br><span class="line">	string s2 = <span class="built_in">to_string</span>(m);</span><br><span class="line">	ll a2 = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="literal">true</span>, <span class="literal">false</span>, s2);</span><br><span class="line">	cout &lt;&lt; a2 - a1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="10-Round-Numbers-S"><a href="#10-Round-Numbers-S" class="headerlink" title="10.Round Numbers S"></a>10.<a href="https://www.luogu.com.cn/problem/P6218">Round Numbers S</a></h3><p>本题需枚举每个数的二进制形式</p>
<p><strong>重点：需要注意数组的大小，避免RE</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line">ll mem[<span class="number">40</span>][N][N];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cnt0, <span class="type">int</span> cnt1, <span class="type">bool</span> limit, <span class="type">bool</span> is_num, vector&lt;<span class="type">int</span>&gt; s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> (cnt0 &gt;= cnt1) &amp;&amp; is_num;</span><br><span class="line">	<span class="keyword">auto</span> &amp;x = mem[i][cnt0][cnt1];</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num &amp;&amp; x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!is_num) ans = <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt0, cnt1, <span class="literal">false</span>, <span class="literal">false</span>, s);</span><br><span class="line">	<span class="type">int</span> up = limit ? s[i] : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span> - is_num; d &lt;= up; d++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(d == <span class="number">0</span>) ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt0 + <span class="number">1</span>, cnt1, limit &amp;&amp; d == up, <span class="literal">true</span>, s);</span><br><span class="line">		<span class="keyword">else</span> ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt0, cnt1 + <span class="number">1</span>,limit &amp;&amp; d == up, <span class="literal">true</span>, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num) x = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll a, b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	a--;</span><br><span class="line">	<span class="keyword">while</span>(a) &#123;</span><br><span class="line">		A.<span class="built_in">push_back</span>(a &amp; <span class="number">1</span>);</span><br><span class="line">		a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		B.<span class="built_in">push_back</span>(b &amp; <span class="number">1</span>);</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">reverse</span>(B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">	ll r1 = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, A);</span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="keyword">sizeof</span> mem);</span><br><span class="line">	ll r2 = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, B);</span><br><span class="line">	<span class="comment">// cout &lt;&lt; r1 &lt;&lt; &#x27; &#x27; &lt;&lt; r2 &lt;&lt; endl;</span></span><br><span class="line">	cout &lt;&lt; r2 - r1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-V"><a href="#11-V" class="headerlink" title="11.V"></a>11.<a href="https://www.luogu.com.cn/problem/P6371">V</a></h3><p>根据题意改题需要存储选取数的数值，为了避免超过内存限制，以1e5为划分，小于1e5使用数位DP，大于则使用暴力枚举进行求解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll x, a, b; </span><br><span class="line">set&lt;<span class="type">int</span>&gt; ss;</span><br><span class="line">string str; </span><br><span class="line">ll dp[<span class="number">12</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, ll mo, <span class="type">bool</span> limit, <span class="type">bool</span> is_num, string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> is_num &amp;&amp; mo % x == <span class="number">0</span>;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num &amp;&amp; dp[i][mo] != <span class="number">-1</span>) <span class="keyword">return</span> dp[i][mo];</span><br><span class="line">	<span class="keyword">if</span>(!is_num) ans = <span class="built_in">dfs</span>(i + <span class="number">1</span>, mo, <span class="literal">false</span>, <span class="literal">false</span>, s);</span><br><span class="line">	<span class="type">int</span> up = limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> d : ss) &#123;</span><br><span class="line">		<span class="keyword">if</span>(d &gt; up) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(!is_num &amp;&amp; d == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, ((mo * <span class="number">10</span>)% x + d) , limit &amp;&amp; d == up, <span class="literal">true</span>, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num) dp[i][mo] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!ss.<span class="built_in">count</span>(i % <span class="number">10</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		i /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 329403446</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		ss.<span class="built_in">insert</span>(str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &lt;= <span class="number">1e5</span>) &#123;</span><br><span class="line">		string s1 = <span class="built_in">to_string</span>(a<span class="number">-1</span>);</span><br><span class="line">		string s2 = <span class="built_in">to_string</span>(b);</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">		ll a1 = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, s1);</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">		ll a2 = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, s2);</span><br><span class="line">		cout &lt;&lt; a2 - a1 &lt;&lt; endl;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll i = x; i &lt;= b; i += x) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(i)) ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-F-x"><a href="#12-F-x" class="headerlink" title="12.F(x)"></a>12.<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4734">F(x)</a></h3><p><code>写记忆化搜索的数组时，实际意义需要与数组的表示一一对应，不然会出现错误</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">ll n, m;</span><br><span class="line">ll f[N][N * <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> limit, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sum &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//剪枝</span></span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>)<span class="keyword">return</span> sum &gt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!limit &amp;&amp; f[pos][sum] != <span class="number">-1</span>)<span class="keyword">return</span>  f[pos][sum];</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> end = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= end; ++i)</span><br><span class="line">		res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit &amp;&amp; i == end, sum - i * (<span class="number">1</span> &lt;&lt; pos));</span><br><span class="line">	<span class="keyword">if</span> (!limit)  f[pos][sum] = res;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dp</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	a.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		a.<span class="built_in">push_back</span>(n % <span class="number">10</span>);	</span><br><span class="line">		n /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (m) &#123;</span><br><span class="line">		sum += (m % <span class="number">10</span>) * (<span class="number">1</span> &lt;&lt; t);</span><br><span class="line">		m /= <span class="number">10</span>; ++t;</span><br><span class="line">	&#125;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(a.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">1</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">	<span class="type">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, i, <span class="built_in">dp</span>(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b; </span><br><span class="line">ll fa;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10</span>][<span class="number">10100</span>];</span><br><span class="line"><span class="type">int</span> cc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// dp数组需要一一对应</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> sum, <span class="type">bool</span> limit, string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; dp[s.<span class="built_in">size</span>() - i - <span class="number">1</span>][sum] != <span class="number">-1</span>) <span class="keyword">return</span> dp[s.<span class="built_in">size</span>() - i - <span class="number">1</span>][sum];</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> up = limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line"> 		ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, sum - d * (<span class="number">1</span> &lt;&lt; (s.<span class="built_in">size</span>() - i - <span class="number">1</span>)), limit &amp;&amp; d == up, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit) dp[s.<span class="built_in">size</span>() - i - <span class="number">1</span>][sum] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fa = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	string s1 = <span class="built_in">to_string</span>(a);</span><br><span class="line">	string s2 = <span class="built_in">to_string</span>(b);</span><br><span class="line">	<span class="type">int</span> len = s1.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// memset(dp, -1,sizeof dp);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		fa += (s1[i] - <span class="string">&#x27;0&#x27;</span>) * (<span class="number">1</span> &lt;&lt; len - i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; fa &lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, ++cc, <span class="built_in">dfs</span>(<span class="number">0</span>, fa, <span class="literal">true</span>, s2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="type">int</span> t; cin&gt;&gt;t; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-Almost-Everywhere-Zero"><a href="#13-Almost-Everywhere-Zero" class="headerlink" title="13.Almost Everywhere Zero"></a>13.<a href="https://atcoder.jp/contests/abc154/tasks/abc154_e"><strong>Almost Everywhere Zero</strong></a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">ll dp[<span class="number">110</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cnt, <span class="type">bool</span> limit, <span class="type">bool</span> is_num, string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cnt &gt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> is_num &amp;&amp; cnt == k;</span><br><span class="line">	ll &amp;x = dp[i][cnt];</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num &amp;&amp; x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!is_num) ans = <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt, <span class="literal">false</span>, <span class="literal">false</span>, s);</span><br><span class="line">	<span class="type">int</span> up = limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span> - is_num; d &lt;= up; d++) &#123;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt + (d != <span class="number">0</span>), limit &amp;&amp; d == up, <span class="literal">true</span>, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num) x = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; k;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, s) &lt;&lt; endl;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-S-Digit-Sum"><a href="#14-S-Digit-Sum" class="headerlink" title="14.S - Digit Sum"></a>14.<a href="https://atcoder.jp/contests/dp/tasks/dp_s"><strong>S - Digit Sum</strong></a></h3><ul>
<li>题目可能会卡string的读入速度，必要时需要切换成char数组</li>
<li>进行取模处理时，结果也必须要进行考虑</li>
<li>记忆化数组的设计需要考虑内存的限制</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">ll dp[N][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> now, <span class="type">bool</span> limit, <span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == len) <span class="keyword">return</span> now == <span class="number">0</span>;</span><br><span class="line">	ll &amp;x = dp[i][now];</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> up = limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">		ans = (ans + <span class="built_in">dfs</span>(i + <span class="number">1</span>, (now + d) % k, limit &amp;&amp; d == up, s)) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit) x = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> s[N];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s, &amp;k);</span><br><span class="line">	len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="comment">// cin &gt;&gt; s &gt;&gt; k;</span></span><br><span class="line">	cout &lt;&lt; (<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, s) - <span class="number">1</span> + mod) % mod &lt;&lt; endl;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-Classy-Numbers"><a href="#15-Classy-Numbers" class="headerlink" title="15.Classy Numbers"></a>15.<a href="https://codeforces.com/problemset/problem/1036/C">Classy Numbers</a></h3><p>经典数位dp，重点是记录非0的个数即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cnt, <span class="type">bool</span> limit, <span class="type">bool</span> is_num, string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cnt &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll &amp;x = dp[i][cnt];</span><br><span class="line">	<span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">return</span> is_num &amp;&amp; cnt &lt;= <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num &amp;&amp; x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!is_num) ans = <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt, <span class="literal">false</span>, <span class="literal">false</span>, s);</span><br><span class="line">	<span class="type">int</span> up = limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span> - is_num; d &lt;= up; d++) &#123;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(i + <span class="number">1</span>, cnt + (d != <span class="number">0</span>), limit &amp;&amp; d == up, <span class="literal">true</span>, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num) x = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll a, b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	string s1 = <span class="built_in">to_string</span>(a<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	ll r1 = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, s1);</span><br><span class="line">	string s2 = <span class="built_in">to_string</span>(b);</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	ll r2 = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, s2);</span><br><span class="line">	cout &lt;&lt; r2 - r1 &lt;&lt; endl;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// memset(dp, -1, sizeof dp);</span></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t; <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-Random-Task-二分-数位DP"><a href="#16-Random-Task-二分-数位DP" class="headerlink" title="16.Random Task 二分  数位DP"></a>16.<a href="https://codeforces.com/problemset/problem/431/D">Random Task</a> <code>二分</code>  <code>数位DP</code></h3><p><strong>题目本意：给定一个数n，查找在区间[n+1, 2*n]中m个满足二进制中1的个数为k个的数。</strong></p>
<p>使用二分的条件是必须具有单调性，比如，当<code>mid</code>取值为<code>n-1</code>时，所查找的区间为<code>[n, 2*n-2]</code>, 假如此时的符合条件的数的个数大于等于<code>m</code>，假如<code>n - 1 --&gt; n</code>, 此时查找的区间为<code>[n + 1, 2*n],</code> 此时比之前增加了<code>2*n -1</code>和 <code>2*n</code>, 又因为 <code>2*n</code> 的二进制<code>1</code>的个数和<code>n</code>一样，所以对结果不产生影响，而<code>2*n - 1</code>也是如此，则大于等于<code>mid</code>的数符合条件的个数都大于等于<code>m</code>，题目为了查找等于<code>m</code>的数，所以缩减右节点，再次进行查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">ll m, k;</span><br><span class="line">ll dp[<span class="number">70</span>][<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> cnt, <span class="type">bool</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cnt &gt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(i == v.<span class="built_in">size</span>()) <span class="keyword">return</span> cnt == k;</span><br><span class="line">	ll &amp;x = dp[v.<span class="built_in">size</span>() - i - <span class="number">1</span>][cnt];</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> up = limit ? v[i] : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">		ans += <span class="built_in">f</span>(i + <span class="number">1</span>, cnt + (d == <span class="number">1</span>), limit &amp;&amp; d == up);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit) x = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	v.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">while</span>(x) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(x &amp; <span class="number">1</span>);</span><br><span class="line">		x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	ll l = <span class="number">1</span>, r = <span class="number">1e18</span>;</span><br><span class="line">	<span class="keyword">while</span>(l &lt; r) &#123; <span class="comment">// 二分查找</span></span><br><span class="line">		ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">get</span>(mid * <span class="number">2</span>) - <span class="built_in">get</span>(mid) &gt;= m) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-范围中美丽整数的数目"><a href="#17-范围中美丽整数的数目" class="headerlink" title="17.范围中美丽整数的数目"></a>17.<a href="https://leetcode.cn/problems/number-of-beautiful-integers-in-the-range/">范围中美丽整数的数目</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfBeautifulIntegers</span>(<span class="params">self, low: <span class="built_in">int</span>, high: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, now: <span class="built_in">int</span>, even_num: <span class="built_in">int</span>, odd_num: <span class="built_in">int</span>, limit: <span class="built_in">bool</span>, is_num: <span class="built_in">bool</span>, s: <span class="built_in">str</span></span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(even_num == odd_num <span class="keyword">and</span> now == <span class="number">0</span>)</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_num: ans = f(i + <span class="number">1</span>, now, even_num, odd_num, <span class="literal">False</span>, <span class="literal">False</span>, s)</span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> limit <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> - <span class="built_in">int</span>(is_num), up+<span class="number">1</span>):</span><br><span class="line">                ans += f(i + <span class="number">1</span>, (now * <span class="number">10</span> + d) % k, even_num + <span class="built_in">int</span>(d % <span class="number">2</span> == <span class="number">0</span>), odd_num + <span class="built_in">int</span>(d % <span class="number">2</span> == <span class="number">1</span>), </span><br><span class="line">                limit <span class="keyword">and</span> d == up, <span class="literal">True</span>, s);</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="built_in">str</span>(high)) - f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="built_in">str</span>(low - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="18-Magic-Numbers"><a href="#18-Magic-Numbers" class="headerlink" title="18.Magic Numbers"></a>18.<a href="https://codeforces.com/problemset/problem/628/D">Magic Numbers</a></h3><p>使用scanf代替cin，不然会卡常</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, d;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line">ll dp[N][N];</span><br><span class="line"><span class="type">int</span> len1,len2;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> now, <span class="type">bool</span> limit, <span class="type">bool</span> is_num, <span class="type">char</span> str[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == len) <span class="keyword">return</span> is_num &amp;&amp; now == <span class="number">0</span>;</span><br><span class="line">    ll &amp;x = dp[len - i - <span class="number">1</span>][now];</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; is_num &amp;&amp; x != <span class="number">-1</span>) <span class="keyword">return</span> x; </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!is_num) ans = <span class="built_in">f</span>(i + <span class="number">1</span>, now, <span class="literal">false</span>, <span class="literal">false</span>, str, len);</span><br><span class="line">    <span class="type">int</span> up = limit ? str[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span> - is_num; s &lt;= up; s++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; s != d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; s == d) <span class="keyword">continue</span>;  </span><br><span class="line">        ans = (ans + <span class="built_in">f</span>(i + <span class="number">1</span>, (now * <span class="number">10</span> + s) % m, limit &amp;&amp; s == up, <span class="literal">true</span>, str, len)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; is_num) x = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s%s&quot;</span>, &amp;m,&amp;d, a, b);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(a), len2 = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(a != <span class="string">&quot;0&quot;</span>)  a[len1 - <span class="number">1</span>] --;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, b, len2) - <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, a, len1) + mod) % mod&lt;&lt; endl;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-Salazar-Slytherin’s-Locket"><a href="#19-Salazar-Slytherin’s-Locket" class="headerlink" title="19.Salazar Slytherin’s Locket"></a>19.<a href="https://codeforces.com/problemset/problem/855/E">Salazar Slytherin’s Locket</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll b, l, r;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">ll dp[<span class="number">11</span>][<span class="number">70</span>][<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用异或运算来代表每个数出现的次数，如果为偶数，那么该位应该为0</span></span><br><span class="line"><span class="comment">// 为了避免超时，memset函数尽量只使用一次，所以，需要携带base参数，可以使记忆化搜索的数组复用</span></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> i, <span class="type">int</span> mask, <span class="type">bool</span> limit, <span class="type">bool</span> is_num, std::vector&lt;<span class="type">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == temp.<span class="built_in">size</span>()) <span class="keyword">return</span> is_num &amp;&amp; mask == <span class="number">0</span>;</span><br><span class="line">	ll &amp;x = dp[base][temp.<span class="built_in">size</span>() - i - <span class="number">1</span>][mask];</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num &amp;&amp; x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!is_num) ans = <span class="built_in">f</span>(base, i + <span class="number">1</span>, mask, <span class="literal">false</span>, <span class="literal">false</span>, temp);</span><br><span class="line">	<span class="type">int</span> up = limit ? temp[i] : base - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span> - is_num; d &lt;= up; d++) &#123;</span><br><span class="line">		ans += <span class="built_in">f</span>(base, i + <span class="number">1</span>, mask ^ (<span class="number">1</span> &lt;&lt; d), limit &amp;&amp; d == up, <span class="literal">true</span>, temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; is_num) x = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A.<span class="built_in">clear</span>(); B.<span class="built_in">clear</span>();</span><br><span class="line">	cin&gt;&gt;b&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	l--;</span><br><span class="line">	<span class="keyword">while</span>(l) &#123;</span><br><span class="line">		A.<span class="built_in">push_back</span>(l % b);</span><br><span class="line">		l /= b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(r) &#123;</span><br><span class="line">		B.<span class="built_in">push_back</span>(r % b);</span><br><span class="line">		r /= b;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">reverse</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">reverse</span>(B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// cout &lt;&lt; f(0, 0, true, false, A) &lt;&lt; endl;</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">f</span>(b, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, B) - <span class="built_in">f</span>(b, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, A) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-统计各位数字都不同的数字个数"><a href="#20-统计各位数字都不同的数字个数" class="headerlink" title="20.统计各位数字都不同的数字个数"></a>20.<a href="https://leetcode.cn/problems/count-numbers-with-unique-digits/">统计各位数字都不同的数字个数</a></h3><p>每个数只出现一次，使用mask二进制标记出现的数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNumbersWithUniqueDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="built_in">str</span>( <span class="built_in">int</span>(math.<span class="built_in">pow</span>(<span class="number">10</span>, n)) - <span class="number">1</span>)</span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, mask: <span class="built_in">int</span>, limit: <span class="built_in">bool</span>, is_num: <span class="built_in">bool</span></span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(is_num)</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_num:</span><br><span class="line">                ans = f(i + <span class="number">1</span>, mask, <span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> limit <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> - <span class="built_in">int</span>(is_num), up + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> mask &gt;&gt; d &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                    ans += f(i + <span class="number">1</span>, mask | (<span class="number">1</span> &lt;&lt; d), limit <span class="keyword">and</span> up == d, <span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>, <span class="literal">False</span>) + <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="21-旋转数字"><a href="#21-旋转数字" class="headerlink" title="21.旋转数字"></a>21.<a href="https://leetcode.cn/problems/rotated-digits/">旋转数字</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotatedDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="built_in">str</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, have: <span class="built_in">bool</span>, limit: <span class="built_in">bool</span>, isNum: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(have <span class="keyword">and</span> isNum)</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isNum:</span><br><span class="line">                ans = f(i + <span class="number">1</span>, have, <span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> limit <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> - <span class="built_in">int</span>(isNum), up+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]:</span><br><span class="line">                    ans += f(i + <span class="number">1</span>, <span class="literal">True</span>, limit <span class="keyword">and</span> up == d, <span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">elif</span> d <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>]:</span><br><span class="line">                    ans += f(i + <span class="number">1</span>, <span class="literal">True</span> <span class="keyword">if</span> have <span class="keyword">else</span> <span class="literal">False</span>, limit <span class="keyword">and</span> up == d, <span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-F-substr-S-https-atcoder-jp-contests-abc295-tasks-abc295-f-kmp"><a href="#22-F-substr-S-https-atcoder-jp-contests-abc295-tasks-abc295-f-kmp" class="headerlink" title="22.F - substr = S[https://atcoder.jp/contests/abc295/tasks/abc295_f] kmp"></a>22.<strong>F - substr = S</strong>[<a href="https://atcoder.jp/contests/abc295/tasks/abc295_f">https://atcoder.jp/contests/abc295/tasks/abc295_f</a>] <code>kmp</code></h3><p><strong>题意：根据给定范围内的字符串，找出所有符合范围的字符串中包含给定子串的个数，最后结果为所有结果的总和。</strong></p>
<p><strong>作法：通过数位DP枚举所有可能出现的数，通过kmp进行快速判断是否匹配了给定的子串。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定一个字符串s，函数f(x) 为x含有子串s的个数</span></span><br><span class="line"><span class="comment">// 题目给出字符串的范围为 L ~ R, S 是给定的子串，求所有满足条件的和</span></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">string s, l, r;</span><br><span class="line"><span class="comment">// kmp匹配的ne数组</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ne</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> cnt, <span class="type">bool</span> limit, <span class="type">bool</span> isNum , string str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(j == s.<span class="built_in">size</span>()) &#123; <span class="comment">// 如果匹配了子串，cnt+1，因为可能还有符合条件的数，所以继续跳转进行匹配</span></span><br><span class="line">		j = ne[j - <span class="number">1</span>];</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == str.<span class="built_in">size</span>()) <span class="keyword">return</span> isNum ? cnt : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记忆化数组要符合逻辑</span></span><br><span class="line">	ll &amp;x = dp[str.<span class="built_in">size</span>() - i - <span class="number">1</span>][s.<span class="built_in">size</span>() - j - <span class="number">1</span>][cnt];</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; isNum &amp;&amp; x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!isNum) ans = <span class="built_in">f</span>(i + <span class="number">1</span>, j, cnt, <span class="literal">false</span>, <span class="literal">false</span>, str);</span><br><span class="line">	<span class="type">int</span> up = limit ? str[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span> - isNum; d &lt;= up; d++) &#123;</span><br><span class="line">		<span class="type">char</span> x = d + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="type">int</span> nj = j;</span><br><span class="line">		<span class="comment">// kmp</span></span><br><span class="line">		<span class="keyword">while</span> (nj &gt; <span class="number">0</span> &amp;&amp; x != s[nj]) nj = ne[nj - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (x == s[nj]) nj ++;</span><br><span class="line">		ans += <span class="built_in">f</span>(i + <span class="number">1</span>, nj, cnt, limit &amp;&amp; up == d, <span class="literal">true</span>, str);	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; isNum) x = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; l &gt;&gt; r;</span><br><span class="line">	l[l.<span class="built_in">size</span>() - <span class="number">1</span>] --;</span><br><span class="line">	ne.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// ne 数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = ne[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(s[i] == s[j]) j++;</span><br><span class="line">		ne[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, r) - <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, l) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-统计整数数目"><a href="#23-统计整数数目" class="headerlink" title="23.统计整数数目"></a>23.<a href="https://leetcode.cn/problems/count-of-integers/">统计整数数目</a></h3><p>求各个数字和符合给定范围内的数，避免记忆化搜索的数组内存溢出，记录是否满足<strong>采用减法记录即可</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span>, min_sum: <span class="built_in">int</span>, max_sum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mod = <span class="built_in">int</span>(<span class="number">1e9</span>)+<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, x: <span class="built_in">int</span>, y: <span class="built_in">int</span>,limit: <span class="built_in">bool</span>, s: <span class="built_in">str</span></span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(x &lt;= <span class="number">0</span> <span class="keyword">and</span> y &gt;= <span class="number">0</span>)</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> limit <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(up+<span class="number">1</span>):</span><br><span class="line">                ans += f(i+<span class="number">1</span>, x - d, y - d, limit <span class="keyword">and</span> d == up, s)</span><br><span class="line">                ans %= mod</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> num1:</span><br><span class="line">            n += <span class="built_in">int</span>(c)</span><br><span class="line">        <span class="keyword">return</span> (f(<span class="number">0</span>,min_sum,max_sum,<span class="literal">True</span>,num2) - f(<span class="number">0</span>,min_sum,max_sum,<span class="literal">True</span>,num1) + <span class="built_in">int</span>(n &gt;= min_sum <span class="keyword">and</span> n &lt;= max_sum)+mod)%mod</span><br></pre></td></tr></table></figure>
<h3 id="24-统计范围内的步进数字数目"><a href="#24-统计范围内的步进数字数目" class="headerlink" title="24.统计范围内的步进数字数目"></a>24.<a href="https://leetcode.cn/problems/count-stepping-numbers-in-range/">统计范围内的步进数字数目</a></h3><p>统计范围内所有相差连续1的数据，第一个数需要特判</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSteppingNumbers</span>(<span class="params">self, low: <span class="built_in">str</span>, high: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        low = <span class="built_in">str</span>(<span class="built_in">int</span>(low)-<span class="number">1</span>)</span><br><span class="line">        mod = <span class="built_in">int</span>(<span class="number">1e9</span>+<span class="number">7</span>)</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, pre: <span class="built_in">int</span>, limit: <span class="built_in">bool</span>, isNum: <span class="built_in">bool</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(isNum)</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isNum:</span><br><span class="line">                ans = f(i+<span class="number">1</span>,pre,<span class="literal">False</span>,<span class="literal">False</span>,s)</span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> limit <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> - <span class="built_in">int</span>(isNum), up+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(d - pre) == <span class="number">1</span> <span class="keyword">or</span> pre == -<span class="number">1</span>:</span><br><span class="line">                    ans += f(i+<span class="number">1</span>, d, limit <span class="keyword">and</span> d == up, <span class="literal">True</span>, s)</span><br><span class="line">                    ans %= mod</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> ( f(<span class="number">0</span>,-<span class="number">1</span>,<span class="literal">True</span>, <span class="literal">False</span>,high) - f(<span class="number">0</span>,-<span class="number">1</span>,<span class="literal">True</span>,<span class="literal">False</span>,low) +mod ) %mod</span><br><span class="line">                </span><br></pre></td></tr></table></figure>
<h3 id="25-Nim-多个数据的数位DP，需要全部考虑"><a href="#25-Nim-多个数据的数位DP，需要全部考虑" class="headerlink" title="25.Nim 多个数据的数位DP，需要全部考虑"></a>25.<a href="https://atcoder.jp/contests/abc317/tasks/abc317_f"><strong>Nim</strong></a> <code>多个数据的数位DP，需要全部考虑</code></h3><ul>
<li>求满足以下条件的三元组的个数 (x1,x2,x3)<code>`xi</code> 是 <code>ai</code>的倍数且 <code>x1 ^ x2 ^ x3 == 0</code> </li>
<li>有题可得三个数的每一位都需要偶数个1,枚举三个数，每个数都需要限制前导0和是否整除ai</li>
<li><code>r</code>: 用于计算每个二进制的和 % ai，最后r==0表示结果满足条件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line">ll n,a1,a2,a3;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; V;</span><br><span class="line"><span class="comment">// 求满足以下条件的三元组的个数</span></span><br><span class="line"><span class="comment">// (x1,x2,x3) xi 是 ai 的倍数</span></span><br><span class="line"><span class="comment">// 且 x1 ^ x2 ^ x3 == 0</span></span><br><span class="line"><span class="comment">// 有题可得三个数的每一位都需要偶数个1</span></span><br><span class="line">ll dp[<span class="number">80</span>][<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> i, ll r1, ll r2, ll r3, <span class="type">bool</span> l1, <span class="type">bool</span> l2, <span class="type">bool</span> l3, <span class="type">bool</span> z1, <span class="type">bool</span> z2, <span class="type">bool</span> z3)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == V.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> !r1 &amp;&amp; !r2 &amp;&amp; !r3 &amp;&amp; z1 &amp;&amp; z2 &amp;&amp; z3;</span><br><span class="line">	&#125;</span><br><span class="line">	ll &amp;x = dp[V.<span class="built_in">size</span>() - i - <span class="number">1</span>][r1][r2][r3][l1][l2][l3][z1][z2][z3];</span><br><span class="line">	<span class="keyword">if</span>(x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> up1 = l1 ? V[i] : <span class="number">1</span>, up2 = l2 ? V[i] : <span class="number">1</span>, up3 = l3 ? V[i] : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 前导0的可能性在循环中考虑</span></span><br><span class="line">	<span class="keyword">for</span>(ll u = <span class="number">0</span>; u &lt;= up1; u++)</span><br><span class="line">		<span class="keyword">for</span>(ll v = <span class="number">0</span>; v &lt;= up2; v++)</span><br><span class="line">			<span class="keyword">for</span>(ll w = <span class="number">0</span>; w &lt;= up3; w++) &#123;</span><br><span class="line">				<span class="keyword">if</span>((u ^ v ^ w) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">				ll nr1 = ((ll)r1 + (u &lt;&lt; (V.<span class="built_in">size</span>() - i - <span class="number">1</span>))) % a1;</span><br><span class="line">				ll nr2 = ((ll)r2 + (v &lt;&lt; (V.<span class="built_in">size</span>() - i - <span class="number">1</span>))) % a2;</span><br><span class="line">				ll nr3 = ((ll)r3 + (w &lt;&lt; (V.<span class="built_in">size</span>() - i - <span class="number">1</span>))) % a3;</span><br><span class="line">				ans = (ans + </span><br><span class="line">					<span class="built_in">f</span>(i+<span class="number">1</span>, nr1, nr2, nr3, l1 &amp;&amp; u == up1, l2 &amp;&amp; v == up2, l3 &amp;&amp; w == up3,</span><br><span class="line">					 !(!z1&amp;&amp;u==<span class="number">0</span>), !(!z2&amp;&amp;v==<span class="number">0</span>), !(!z3&amp;&amp;w==<span class="number">0</span>))) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">	x = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n,&amp;a1,&amp;a2,&amp;a3);</span><br><span class="line">	<span class="comment">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		V.<span class="built_in">push_back</span>(n%<span class="number">2</span>);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;V.size()&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">reverse</span>(V.<span class="built_in">begin</span>(), V.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// for(auto x : V) cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">	cout &lt;&lt; ( <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>) + mod ) % mod &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-同类分布"><a href="#26-同类分布" class="headerlink" title="26.同类分布"></a>26<strong>.<a href="https://www.luogu.com.cn/problem/P4127">同类分布</a></strong></h3><p>数位DP：定义一个递归函数 <code>f(int i, ll sum, ll all, bool limt)</code>，sum代表所有数字的和，all代表原数字。但是这样会导致记忆化数组无法记录all的数值，会出现内存溢出，所以要对all进行取模操作，以减少数据的大小，但是取模操作的mod和sum息息相关，所以我们需要先对所有可能出现的mod进行枚举，然后最后判断时，不仅要判断all可以整除mod，sum和mod也相等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mod;</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> i, ll sum, ll all, <span class="type">bool</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> sum == mod &amp;&amp; all == <span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	ll &amp;x = dp[A.<span class="built_in">size</span>() - i - <span class="number">1</span>][sum][all];</span><br><span class="line">	<span class="keyword">if</span>(!limit &amp;&amp; x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> up = limit ? A[i] : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">		ans += <span class="built_in">f</span>(i + <span class="number">1</span>, sum + d, (all * <span class="number">10</span> + d) % mod, limit &amp;&amp; d == up);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit) x = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	A.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">while</span>(x) &#123;</span><br><span class="line">		A.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">		x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 枚举所有可能的mod，减少内存的使用</span></span><br><span class="line">	<span class="keyword">for</span>(mod = <span class="number">1</span>; mod &lt;= <span class="number">9</span> * A.<span class="built_in">size</span>(); mod++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">		res += <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	ll a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">get</span>(b) - <span class="built_in">get</span>(a<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="27-Daniel-and-Spring-Cleaning-区间数位"><a href="#27-Daniel-and-Spring-Cleaning-区间数位" class="headerlink" title="27.Daniel and Spring Cleaning 区间数位"></a>27.<a href="https://codeforces.com/problemset/problem/1245/F">Daniel and Spring Cleaning</a> <code>区间数位</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line">ll l, r;</span><br><span class="line">ll dp[<span class="number">70</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">bool</span> l1, <span class="type">bool</span> l2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == A.<span class="built_in">size</span>())  &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll &amp;x = dp[A.<span class="built_in">size</span>() - i - <span class="number">1</span>][l1][l2];</span><br><span class="line">	<span class="keyword">if</span>(x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> up1 = l1 ? A[i] : <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> up2 = l2 ? B[i] : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt;= up1; u++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt;= up2; v++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(u &amp; v) <span class="keyword">continue</span>;</span><br><span class="line">			ans += <span class="built_in">f</span>(i + <span class="number">1</span>, l1 &amp;&amp; u == up1, l2 &amp;&amp; v == up2);</span><br><span class="line">		&#125;</span><br><span class="line">	x = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll l, ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt; <span class="number">0</span> || r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &gt; r) <span class="built_in">swap</span>(l, r);</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	A.<span class="built_in">clear</span>(), B.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">while</span>(r) &#123;</span><br><span class="line">		A.<span class="built_in">push_back</span>(r%<span class="number">2</span>);</span><br><span class="line">		r /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(l) &#123;</span><br><span class="line">		B.<span class="built_in">push_back</span>(l%<span class="number">2</span>);</span><br><span class="line">		l /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m = A.<span class="built_in">size</span>() - B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">while</span>(m--) B.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">reverse</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">reverse</span>(B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">0</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t); <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">		cout &lt;&lt; <span class="built_in">solve</span>(r, r) - <span class="built_in">solve</span>(r, l - <span class="number">1</span>) - <span class="built_in">solve</span>(l - <span class="number">1</span>, r) + <span class="built_in">solve</span>(l - <span class="number">1</span>, l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="28-Investigation-区间数位DP"><a href="#28-Investigation-区间数位DP" class="headerlink" title="28.Investigation 区间数位DP"></a>28.<a href="https://lightoj.com/problem/investigation">Investigation</a> <code>区间数位DP</code></h3><p>如果直接记录当前数字和 mod k 和 数位和 mod k 的状态，会导致内存溢出。所以需要重新考虑，又因为l和r的范围为int，所以最大的数位和不超过100，如果大于100，结果输出0即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line">ll l, r, k;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">ll dp[<span class="number">10</span>][N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> sum, <span class="type">int</span> digits_sum, <span class="type">bool</span> l1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == A.<span class="built_in">size</span>()) <span class="keyword">return</span> sum == <span class="number">0</span> &amp;&amp; digits_sum == <span class="number">0</span>;</span><br><span class="line">    ll &amp;x = dp[A.<span class="built_in">size</span>() - i - <span class="number">1</span>][sum][digits_sum];</span><br><span class="line">    <span class="keyword">if</span>(!l1 &amp;&amp; x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> up = l1 ? A[i] : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++)</span><br><span class="line">        ans += <span class="built_in">f</span>(i + <span class="number">1</span>, (sum * <span class="number">10</span> + d) % k, (digits_sum + d) % k, l1 &amp;&amp; d == up);</span><br><span class="line">    <span class="keyword">if</span>(!l1) x = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    A.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        A.<span class="built_in">pb</span>(x % <span class="number">10</span>);</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">100</span>) <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, cnt, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, cnt, <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>));</span><br><span class="line">        &#125; </span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="29-吉哥系列故事——恨7不成妻-对于平方的特殊处理"><a href="#29-吉哥系列故事——恨7不成妻-对于平方的特殊处理" class="headerlink" title="29.吉哥系列故事——恨7不成妻 对于平方的特殊处理"></a>29.<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4507">吉哥系列故事——恨7不成妻</a> <code>对于平方的特殊处理</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll l, r;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DP</span> &#123;</span><br><span class="line">    ll cnt, sum, sqsum;</span><br><span class="line">    <span class="built_in">DP</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DP</span>(ll cnt, ll sum, ll sqsum) : <span class="built_in">cnt</span>(cnt), <span class="built_in">sum</span>(sum), <span class="built_in">sqsum</span>(sqsum) &#123;&#125;</span><br><span class="line">&#125;dp[<span class="number">20</span>][<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">ll ten[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">DP <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> sum, <span class="type">int</span> digits_sum, <span class="type">bool</span> l1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == A.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">DP</span>(sum != <span class="number">0</span> &amp;&amp; digits_sum != <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!l1 &amp;&amp; dp[A.<span class="built_in">size</span>()-i<span class="number">-1</span>][sum][digits_sum].cnt != <span class="number">-1</span>) <span class="keyword">return</span> dp[A.<span class="built_in">size</span>()-i<span class="number">-1</span>][sum][digits_sum];</span><br><span class="line">    DP ans = <span class="built_in">DP</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> up = l1 ? A[i] : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(d == <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">        DP t = <span class="built_in">f</span>(i + <span class="number">1</span>, (sum * <span class="number">10</span> + d) % <span class="number">7</span>, (digits_sum + d) % <span class="number">7</span>, l1 &amp;&amp; d == up);</span><br><span class="line">          ans.cnt += t.cnt;</span><br><span class="line">          ans.cnt %= mod;</span><br><span class="line"></span><br><span class="line">          ans.sum += t.sum + t.cnt * d % mod * ten[A.<span class="built_in">size</span>()-i<span class="number">-1</span>] % mod;</span><br><span class="line">          ans.sum %= mod;</span><br><span class="line"></span><br><span class="line">          ans.sqsum += t.cnt * d * d % mod * ten[A.<span class="built_in">size</span>()-i<span class="number">-1</span>] % mod * ten[A.<span class="built_in">size</span>()-i<span class="number">-1</span>] % mod;</span><br><span class="line">          ans.sqsum += t.sqsum + <span class="number">2</span> * d * ten[A.<span class="built_in">size</span>()-i<span class="number">-1</span>] % mod * t.sum % mod;</span><br><span class="line">          ans.sqsum %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!l1) dp[A.<span class="built_in">size</span>()-i<span class="number">-1</span>][sum][digits_sum] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    A.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        A.<span class="built_in">pb</span>(x % <span class="number">10</span>);</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>).sqsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ten[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) ten[i] = (ten[i - <span class="number">1</span>] * <span class="number">10</span>) % mod;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="comment">// memset(dp, -1, sizeof dp);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,( <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>) + mod ) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2023/09/16/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h2><h2 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h2><h3 id="1-Compress-Words-最大前缀和后缀"><a href="#1-Compress-Words-最大前缀和后缀" class="headerlink" title="1.Compress Words 最大前缀和后缀"></a>1.<a href="https://codeforces.com/problemset/problem/1200/E">Compress Words</a> <code>最大前缀和后缀</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">string s, ans;</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(string ss)</span> </span>&#123; <span class="comment">//求出合并的字符串的最大前缀和最大后缀相等的长度</span></span><br><span class="line">    <span class="keyword">if</span>(ss.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; ss.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; ss[i] != ss[j]) j=ne[j<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(ss[i] == ss[j]) j++;</span><br><span class="line">		ne[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ne[ss.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">min</span>(s.<span class="built_in">size</span>(), ans.<span class="built_in">size</span>()); <span class="comment">// 合并的字符串的最大前缀和后缀最大为两个合并字符串的最小长度</span></span><br><span class="line">		<span class="comment">//需要加一个不会出现的字符，避免最大前缀和后缀长度超过其中某一个字符串的长度,造成越界，使结果发生错误</span></span><br><span class="line">		string ns = s + <span class="string">&#x27;#&#x27;</span> + ans.<span class="built_in">substr</span>(ans.<span class="built_in">size</span>()-l, l); </span><br><span class="line">		<span class="type">int</span> m = <span class="built_in">kmp</span>(ns);</span><br><span class="line">		<span class="keyword">if</span>(m &lt; s.<span class="built_in">size</span>())</span><br><span class="line">		    ans += s.<span class="built_in">substr</span>(m);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Censoring-S-栈"><a href="#2-Censoring-S-栈" class="headerlink" title="2.Censoring S 栈"></a>2.<a href="https://www.luogu.com.cn/problem/P4824">Censoring S</a> <code>栈</code></h3><ul>
<li>使用kmp扫描字符串，并使用栈存下扫过的部分，并开一个数组，记录每个部分对应的进行kmp匹配时查找字符串所处的下标，即<code>j</code></li>
<li>当匹配成功后，从栈中移出匹配串的所有部分，并更新<code>j</code>为删除后所该在的位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ne[N], stack[N], f[N];</span><br><span class="line">string s,t;</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="comment">// 使用栈存储留下的字符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; t[i] != t[j]) j=ne[j<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(t[i] == t[j]) j++;</span><br><span class="line">		ne[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; s[i] != t[j]) j=ne[j<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(s[i] == t[j]) j++;</span><br><span class="line">		f[i] = j;</span><br><span class="line">		stack[++top] = i;</span><br><span class="line">		<span class="keyword">if</span>(j == t.<span class="built_in">size</span>()) &#123; <span class="comment">// 如果匹配成功，将匹配成功的字符串移出栈中，j跳到上次匹配时该在的位置</span></span><br><span class="line">			top -= t.<span class="built_in">size</span>();</span><br><span class="line">			j = f[stack[top]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++) <span class="comment">// 输出栈中存储的字符</span></span><br><span class="line">		cout &lt;&lt; s[stack[i]];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-OKR-Periods-of-Words-KMP-最短前缀后缀"><a href="#3-OKR-Periods-of-Words-KMP-最短前缀后缀" class="headerlink" title="3.OKR-Periods of Words KMP  最短前缀后缀"></a>3.<a href="https://www.luogu.com.cn/problem/P3435">OKR-Periods of Words</a> <code>KMP</code>  <code>最短前缀后缀</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> ne[N], srt[N];</span><br><span class="line"><span class="comment">// 本题主要是求给定字符串的最短前后缀相等距离</span></span><br><span class="line"><span class="comment">// 根据ne数组的定义可得，如果ne[j]不为0，代表有相等的长度，所以j=ne[j]，直到</span></span><br><span class="line"><span class="comment">// ne[j]==0,此时j为最短长度</span></span><br><span class="line"><span class="comment">// 假如前缀为s，源字符串为a，为满足条件：a是s+s的前缀，且s的长度最长</span></span><br><span class="line"><span class="comment">// 所以： 需要找出a的最短前缀后缀相同的字符串，该位置越短，代表前缀越长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;str+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">		<span class="keyword">if</span>(str[i] == str[j+<span class="number">1</span>]) j++;</span><br><span class="line">		ne[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; i++, j = i) &#123;</span><br><span class="line">		<span class="keyword">while</span>(ne[j]) j = ne[j];</span><br><span class="line">		<span class="keyword">if</span>(ne[i]) ne[i] = j;</span><br><span class="line">		ans += i - j;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Merge_Sort</title>
    <url>/2023/06/27/Merge-Sort/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>归并排序（<a href="https://en.wikipedia.org/wiki/Merge_sort">merge sort</a>）是高效的基于比较的稳定排序算法</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>基于分治思想将数组分为两个部分，使这两部分有序后，再进行合并，使最终序列有序，即不断对分开的序列进行递归处理，使序列的每一部分都有序，然后进行合并，得到最终的有序序列。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l, mid), <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) temp[k ++] = q[i ++];</span><br><span class="line">        <span class="keyword">else</span> temp[k ++] = q[j ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) temp[k ++] = q[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) temp[k ++] = q[j ++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++,j++) q[i] = temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展知识：<code>merge(start1, end1, start2, end2, arr, cmp)</code> 函数</p>
<p>将两个升序的序列<code>a</code>,<code>b</code>按照<code>a</code>序列的区间 $[start1, end1)$内的数 和<code>b</code>序列的区间 $[start2, end2)$ 的数进行合并 ，并存储到<code>arr</code>中。</p>
<p>优化后的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l, mid), <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">merge</span>(q + l, q + mid + <span class="number">1</span>, q + j, q + r + <span class="number">1</span>, temp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++,j++) q[i] = temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓展题型"><a href="#拓展题型" class="headerlink" title="拓展题型"></a>拓展题型</h2><h3 id="1-求逆序对的数量"><a href="#1-求逆序对的数量" class="headerlink" title="1.求逆序对的数量"></a>1.求逆序对的数量</h3><p><a href="https://www.acwing.com/problem/content/790/">题目信息</a></p>
<p>关键：当数组有序时，数组中的逆序对为0，所以在归并排序中，每次和并数组两部分时都会减少逆序对的数量，同样也可以统计逆序对的数量，设左半部分的数为 <code>a[i]</code>, 右半部分的为 <code>a[j]</code> 如果 <code>a[i] &gt; a[j]</code>, 则左半部分从i后的所有数都大于<code>a[j]</code>, 这时便可以统计逆序对的数量了，直接全部计算即可，即 <code>m - i + 1</code>(m为进行分治的部分)，因为数组有序时，逆序对的数量为0，这样才不会少统计。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l, m), <span class="built_in">merge_sort</span>(m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = m + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[j]) t[k ++] = a[j ++], ans += m - i + <span class="number">1</span>; <span class="comment">// 统计数目</span></span><br><span class="line">        <span class="keyword">else</span> t[k ++] = a[i ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m) t[k ++] = a[i ++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) t[k ++] = a[j ++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) a[i] = t[j]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法基础题</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS</title>
    <url>/2023/06/16/BFS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-走迷宫"><a href="#1-走迷宫" class="headerlink" title="1.走迷宫"></a>1.走迷宫</h4><p>给定一个 <strong>n×m</strong> 的二维整数数组，用来表示一个迷宫，数组中只包含 <strong>0</strong> 或 <strong>1</strong>，其中 <strong>0</strong> 表示可以走的路，<strong>1</strong> 表示不可通过的墙壁。</p>
<p>最初，有一个人位于左上角 <strong>(1,1)</strong> 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p>
<p>请问，该人从左上角移动至右下角 <strong>(n,m)</strong>处，至少需要移动多少次。</p>
<p>数据保证 <strong>(1,1)</strong> 处和 <strong>(n,m)</strong> 处的数字为 <strong>0</strong>，且一定至少存在一条通路。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <strong>n</strong> 和 <strong>m</strong>。</p>
<p>接下来 <strong>n </strong>行，每行包含 <strong>m</strong> 个整数（<strong>0 或 1</strong>），表示完整的二维数组迷宫。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><strong>1  ≤  n,m  ≤  100</strong></p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">0 1 0 0 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 1 0</span><br></pre></td></tr></table></figure>
<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N], d[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = p.first + dx[i], ny = p.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= m &amp;&amp; g[nx][ny] == <span class="number">0</span> &amp;&amp; d[nx][ny] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[nx][ny] = d[p.first][p.second] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-有向图的拓扑序列"><a href="#2-有向图的拓扑序列" class="headerlink" title="2.有向图的拓扑序列"></a>2.有向图的拓扑序列</h4><p>给定一个 <strong>n</strong> 个点 <strong>m</strong> 条边的有向图，点的编号是 <strong>1</strong> 到 <strong>n</strong>，图中可能存在重边和自环。</p>
<p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 <strong>−1</strong>。</p>
<p>若一个由图中所有点构成的序列 <strong>A</strong> 满足：对于图中的每条边 <strong>(x,y)</strong>，<strong>x</strong> 在 <strong>A</strong> 中都出现在 <strong>y</strong> 之前，则称 <strong>A</strong> 是该图的一个拓扑序列。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <strong>n</strong> 和 <strong>m</strong>。</p>
<p>接下来 <strong>m</strong> 行，每行包含两个整数 <strong>x</strong> 和 <strong>y</strong>，表示存在一条从点 x 到点 y 的有向边 <strong>(x,y)</strong>。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p>
<p>否则输出 <strong>-1</strong>。</p>
<h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><script type="math/tex; mode=display">1≤n,m≤  10^5</script><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &lt;ctrin</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> q[N],d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) <span class="keyword">if</span>(!d[i]) q[++ tt] = i;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = q[hh ++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            d[j] --;</span><br><span class="line">            <span class="keyword">if</span>(!d[j]) q[++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        d[b] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">toposort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法基础题</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick_Sort</title>
    <url>/2023/06/27/Quick-Sort/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>快速排序（英语：Quicksort），又称分区交换排序（英语：partition-exchange sort），简称「快排」，是一种被广泛运用的排序算法。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>快速排序的工作原理是通过分治的方式对数组进行排序</p>
<p> 快速排序基本分为三个过程：</p>
<ol>
<li>将数组划分成两个部分 (两部分保持相对大小关系)</li>
<li>对两部分进行递归求解</li>
<li>无需合并，此时数组已经是有序</li>
</ol>
<p>性质：保证在一个<code>x</code>值的约束下, 数组分为两部分，一部分总是小于<code>x</code>，另一部分大于<code>x</code>, 所以在进行快速排序的过程中，数组总是分成两部分，且两部分保持相对大小。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = q[(l + r) &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展题型"><a href="#扩展题型" class="headerlink" title="扩展题型"></a>扩展题型</h2><h3 id="1-第k个数"><a href="#1-第k个数" class="headerlink" title="1.第k个数"></a>1.第k个数</h3><p> <a href="https://www.acwing.com/problem/content/788/">题目信息</a> </p>
<p>相关点：因为快速排序能够保证数组有两部分能保持相对大小，所以求第<code>k</code>个数，我们可以根据其下标<code>k-1</code>快速选择结果所存在的数组部分进行递归，从而快速得到结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="type">int</span> x = q[(l + r) &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k - <span class="number">1</span> &lt;= j) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(l, j);   <span class="comment">//下标小于等于j，代表数值小于等于x</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓展信息：<code>nth_element(first, nth, last, cmp)</code> 函数用法</p>
<p>该函数会将某个序列按照默认的升序排序，从该序列中找到第 n 小的元素 K，并将 K 移动到序列中第 n 的位置处。不仅如此，整个序列经过 nth_element() 函数处理后，所有位于 K 之前的元素都比 K 小，所有位于 K 之后的元素都比 K 大。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法基础题</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/06/15/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>test1</title>
    <url>/2023/06/15/test1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你好&quot;</span> &lt;&lt; endl</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_base</title>
    <url>/2024/09/18/cpp-base/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h2><p>在C++中，左值（<code>lvalue</code>）和右值（<code>rvalue</code>）是表达式的两种基本分类，它们决定了表达式的结果在内存中的位置和状态。左值通常指的是具有持久状态的对象，它们有明确的内存地址，可以被多次赋值。而右值通常是临时的、没有持久状态的值，它们通常没有内存地址，或者其内存地址在表达式结束后就变得无效。</p>
<p><em>引入引用的目的: 为对象创建别名，方便操作，并减少开销</em></p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>左值引用是C++98就有的特性，它允许我们为已存在的对象创建一个别名。左值引用必须被初始化为一个左值，即一个具有持久状态的对象。</p>
<p>目的: 在C++中使用引用，可以让我们直接访问和操作另一个变量的内存地址，而不需要通过指针的解引用操作。引用在语法上比指针更简洁，且在许多情况下更安全，且高效。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b = a; <span class="comment">// b是a的引用</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// 输出: a = 100, b = 100</span></span><br><span class="line"></span><br><span class="line">    b = <span class="number">200</span>; <span class="comment">// 更改b的值也会更改a的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// 输出: a = 200, b = 200</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="comment">// 表示修改b的值为c的值, 不会产生效果，b 的地址依然与 a 相同</span></span><br><span class="line">    b = c; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>引用主要用于函数参数和返回值，以及类的成员变量等场景，以提供对原始数据的直接访问，从而提高程序的效率和可读性。</li>
<li>引用可以是<code>const</code>的，这表示你不能通过引用来修改它所指向的对象的值。</li>
<li>引用在内部实现上通常是通过指针来实现的，但它们在语法和用途上与指针有显著的不同。引用提供了更直观、更安全的访问方式。</li>
</ul>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用是C++11新增的特性，它允许我们为右值（即临时对象或即将被销毁的对象）创建一个引用。这样，我们就可以对右值进行更复杂的操作，比如移动语义（move semantics）。</p>
<p>目的: 因为左值只能对已存在的对象进行绑定，为了支持移动语义（move semantics），右值引用允许我们在对象被销毁前“窃取”其资源（如动态分配的内存、文件句柄等），而不是进行深拷贝。这可以显著提高性能，特别是在处理大型对象或容器时。</p>
<p>完美转发（perfect forwarding）是另一个与右值引用相关的概念，它允许我们将参数原封不动地传递给另一个函数，无论是左值还是右值。这通过模板和<code>std::forward</code>函数实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>左值引用（<code>T&amp;</code>）是C++98就有的特性，用于为已存在的对象创建别名。</li>
<li>右值引用（<code>T&amp;&amp;</code>）是C++11新增的特性，用于为右值（即临时对象）创建引用，支持移动语义和完美转发等高级特性。</li>
<li>右值引用的主要用途不是直接绑定到字面量或简单的右值表达式上，而是在函数参数和返回值中，以实现更高效的资源管理和更灵活的代码编写方式。</li>
<li>绑定左值的引用是左值引用，绑定右值的引用是右值引用，左值引用不能绑定右值，因为右值不能修改。</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>​    在不同文件定义相同的名称的<code>const</code>对象，是不同的对象。如果想在多个文件之间共享<code>const</code>对象，必须在变量的定义之前添加extern关键字。编译器就已经确定数值了。</p>
<h3 id="const-的引用"><a href="#const-的引用" class="headerlink" title="const 的引用"></a><code>const</code> 的引用</h3><ol>
<li><p>常量引用可以常量和变量，常量引用本身不能修改，但原变量可以修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; c = a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; d = b;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>常量引用可以绑定<code>临时变量</code>, 因为临时变量是右值，是不能被修改的，所以用正常的引用无法绑定，但常量引用可以，常量引用不能修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; b = a*<span class="number">3</span>;</span><br><span class="line"><span class="comment">// 报错  int &amp; c = a*3; </span></span><br><span class="line"><span class="comment">// 可以通过非常量修改 a</span></span><br><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量引用可以绑定不同类型的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure>
<p>上面的代码相当于  正常引用不可以，因为<code>temp</code>是临时值，正常引用不能绑定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上面代码会做隐式转换,相当于下面代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> temp  = dval;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = temp;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="poniter-to-const-指向常量的指针"><a href="#poniter-to-const-指向常量的指针" class="headerlink" title="poniter to const 指向常量的指针"></a><code>poniter to const</code> 指向常量的指针</h3><p>指针指向的内容是常量或者变量 <code>const 修饰的是指针指向的对象的数据，即数据不能修改，但指针本身可以改变指向，就是指针指向的数据是 &quot;const int&quot;</code></p>
<p>如果是变量同引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a_ptr = &amp;a; <span class="comment">// int const* a_ptr = &amp;a;</span></span><br><span class="line">std::cout &lt;&lt; *a_ptr &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">100</span>;</span><br><span class="line">a_ptr = &amp;b;</span><br><span class="line">std::cout &lt;&lt; *a_ptr &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a><code>const</code>指针</h3><p><code>const 修饰的是指针本身，即指针本身不能改变指向，就是指针本身是 &quot;const&quot;的，不能发生改变</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;a;</span><br><span class="line"> <span class="comment">// 报错 p = &amp;b;</span></span><br></pre></td></tr></table></figure>
<p>但是const指针不能指向常量，因为未对指针指向对象的内容进行限制，会报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 报错 int* const p = &amp;a; </span></span><br></pre></td></tr></table></figure>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层<code>const</code></h3><p>指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题</p>
<p>用名词顶层<code>const（top-level const）</code>表示指针本身是个常量，而用名词底层<code>const（low-level const）</code>表示指针所指的对象是一个常量。</p>
<p>顶层<code>const</code>可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。</p>
<p>底层<code>const</code>则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层<code>const</code>也可以是底层<code>const</code>，这一点和其他类型相比区别明显：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//不能改变p1的值，这是一个顶层const</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> pi = &amp;i;</span><br><span class="line"><span class="comment">//不能改变ci的值，这是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci  = <span class="number">42</span>;</span><br><span class="line"><span class="comment">//允许改变p2的值，这是一个底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *  p2 = &amp;ci;</span><br><span class="line"><span class="comment">//靠右边的const是顶层const，靠左边的const是底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = p2;</span><br><span class="line"><span class="comment">//用于声明引用的const都是底层const, 引用默认是顶层const，不能改变指向</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;</span><br></pre></td></tr></table></figure>
<p>底层<code>const</code>的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换</p>
<p>下述 p4与p2指向同一个地址，p4不是底层const，说明可以修改a的数据，这样p2就无法保持不变的特性，所以报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指针赋值要注意关注底层const</span></span><br><span class="line"><span class="comment">//p2拥有底层const,p4无底层const，所以无法赋值</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;a;</span><br><span class="line"><span class="comment">//int * p4 = p2;</span></span><br></pre></td></tr></table></figure>
<h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a><code>constexpr</code>和常量表达式</h3><p>常量表达式<code>（const expression）</code>是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的<code>const</code>对象也是常量表达式。后面将会提到，<code>C++</code>语言中有几种情况下是要用到常量表达式的。</p>
<p>我们先在global.h中声明一个全局函数返回固定大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>在global.cpp中实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们用const定义一些常量表达式</p>
<p>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//max_files是一个常量表达式</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//limit是一个常量表达式</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//staff_size不是常量表达式,无const声明</span></span><br><span class="line">    <span class="type">int</span> staff_size = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//sz不是常量表达式,运行时计算才得知</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">GetSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管<code>staff_size</code>的初始值是个字面值常量，但由于它的数据类型只是一个普通<code>int</code>而非<code>const int</code>，所以它不属于常量表达式。</p>
<p>另一方面，尽管<code>sz</code>本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。</p>
<p>在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。</p>
<p>当然可以定义一个<code>const</code>变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。</p>
<p><strong>C++11新标准</strong></p>
<p>C++11新标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。声明为<code>constexpr</code>的变量一定是一个常量，而且必须用常量表达式初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//20是一个常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//mf+1是一个常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//错误，GetSize()不是一个常量表达式，需要运行才能返回</span></span><br><span class="line"><span class="comment">//constexpr int sz = GetSize();</span></span><br></pre></td></tr></table></figure>
<p>尽管不能使用普通函数作为<code>constexpr</code>变量的初始值，新标准允许定义一种特殊的<code>constexpr</code>函数。</p>
<p>这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用<code>constexpr</code>函数去初始化<code>constexpr</code>变量了。</p>
<p>我们在<code>global.h</code>中定义一个<code>constexpr</code>函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetSizeConst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免在多个源文件中包含同一个头文件而导致的多重定义错误，可以将 <code>constexpr</code> 函数声明为 <code>inline</code>。</p>
<p><code>inline</code> 关键字允许在多个翻译单元中定义同一个函数，而不会引起链接错误。</p>
<p>接下来在定义一个<code>constexpr</code>变量就行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">GetSizeConst</span>();</span><br></pre></td></tr></table></figure>
<h3 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a><strong>指针和<code>constexpr</code></strong></h3><p>必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p是一个指向整形常量的指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//q是一个指向整数的常量指针 类似与顶层const</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>或者0，或者是存储于某个固定地址中的对象。</p>
<p>函数体内定义的变量一般来说并非存放在固定地址中，因此<code>constexpr</code>指针不能指向这样的变量。</p>
<p>定义于所有函数体之外的对象其地址固定不变，能用来初始化<code>constexpr</code>指针</p>
<p>global_i是一个全局变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//constexpr指针只能绑定固定地址</span></span><br><span class="line"><span class="comment">//constexpr int *p = &amp;mvalue;</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//可以绑定全局变量，全局变量地址固定</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *cp = &amp;global_i;</span><br></pre></td></tr></table></figure>
<p>可以修改<code>constexpr</code>指向的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p = &amp;global_i;</span><br><span class="line"><span class="comment">//修改p指向的内容数据</span></span><br><span class="line">*p = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<p>global_i是一个全局变量，下面这个指针是什么类型？能否修改<code>cp</code>指向的数据的内容(<code>*cp = 200</code>)？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> * cp = &amp;global_i;</span><br><span class="line"><span class="comment">// 不可以，类似与 const int * con cp = &amp;global_i;</span></span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>顶层 <code>const</code>约束的是自己本身，所以在某些情况下可以忽视，因为它只能保证自身符合不变的特性，当执行对象的拷贝操作时，对于拷入的对象不存在限制，拷入对象的不变性，由它自己保证。对于拷出操作，根据自己的类型限制执行对象的类型，如</p>
<p><code>const int a = 10;  // 这样会报错 int* p2 = &amp;a;</code></p>
</li>
<li><p>底层<code>const</code>表示指针所指的对象是一个常量. (引用天生是底层) , 当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，且两个对象的数据类型必须能够转换。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>cpp-study</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
</search>
