<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git-study</title>
      <link href="/2023/06/29/git-study/"/>
      <url>/2023/06/29/git-study/</url>
      
        <content type="html"><![CDATA[<h1 id="git的基本概念"><a href="#git的基本概念" class="headerlink" title="git的基本概念"></a>git的基本概念</h1><ul><li>工作区：仓库的目录。工作区是独立于各个分支的。</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li><li>版本库：存放所有已经提交到本地仓库的代码版本。(存在一个<code>Head</code>指针指向当前版本树，代表现在所处的版本，将暂存区的内容提交到版本库时，会在<code>Head</code>指针后建立一个新的节点，代表新的版本，然后移动<code>Head</code>指针)</li><li>版本结构：树结构，树中每个节点代表一个代码版本。</li></ul><h1 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h1><ol><li><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在~/.gitconfig文件中</li><li><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在~/.gitconfig文件中</li><li><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中</li><li><code>git add XX</code>：将XX文件添加到暂存区</li><li><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</li><li><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉</li><li><code>git commit -m</code> “给自己看的备注信息”：将暂存区的内容提交到当前分支</li><li><code>git status</code>：查看仓库状态</li><li><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</li><li><code>git log</code>：查看当前分支的所有版本</li><li><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</li><li><code>git reset --hard HEAD^ 或 git reset --hard HEAD~</code>：将代码库回滚到上一个版本</li><li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li><li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li><li><code>git reset --hard 版本号</code>：回滚到某一特定版本</li><li><code>git checkout — XX或git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销</li><li><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</li><li><code>git push -u (第一次需要-u以后不需要</code>：将当前分支推送到远程仓库</li><li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li><li><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</li><li><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支</li><li><code>git branch</code>：查看所有分支和当前所处分支</li><li><code>git checkout branch_name</code>：切换到branch_name这个分支</li><li><code>git merge branch_name</code>：将分支branch_name合并到当前分支上</li><li><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</li><li><code>git branch branch_name</code>：创建新分支</li><li><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支</li><li><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支</li><li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</li><li><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</li><li><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</li><li><code>git checkout -t origin/branch_name</code>将远程的branch_name分支拉取到本地</li><li><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</li><li><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</li><li><code>git stash drop</code>：删除栈顶存储的修改</li><li><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</li><li><code>git stash list</code>：查看栈中所有元素</li></ol><h2 id="命令实战"><a href="#命令实战" class="headerlink" title="命令实战"></a>命令实战</h2><ol><li><p>通过<code>git init</code> 将当前目录配置成git仓库</p></li><li><p>编写一个文件<code>readme.txt</code>并写入内容<code>111</code></p></li><li><p>使用<code>git status</code> 查看当前仓库状态，在master分支存在文件没有添加任何要提交的内容，但存在未跟踪的文件（使用“git add”进行跟踪）。</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629205201067.png" alt="image-20230629205201067" style="zoom:50%;" /></p></li><li><p>使用<code>git add filename</code>对该文件进行追踪，即加入暂存区中。使用<code>git status</code>查看当前仓库状态：</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629205932637.png" alt="image-20230629205932637" style="zoom:50%;" /></p></li><li><p>使用<code>git commit</code>提交当前暂存区的内容到当前分支(<code>进行可持久化</code>)(<code>fitst commit</code>)</p></li></ol><p>​        <img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629210205398.png" alt="image-20230629210205398" style="zoom: 50%;" /></p><p>​        再次查看当前仓库的状态，发现暂存区已经清空</p><p>​        <img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629210241696.png" alt="image-20230629210241696" style="zoom:50%;" ></p><ol><li><p>对源文件进行修改后(<code>追加222</code>，再次提交进行持久化，观察各个步骤，仓库的状态。(<code>second commit</code>)</p><ul><li><p>修改<code>readme.txt</code>, 使用<code>git status</code>查看</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629212206964.png" alt="image-20230629212206964" style="zoom:50%;" /></p><p>出现两种操作:</p><ol><li><code>git add &lt;file&gt;</code> ：将修改提交到暂存区</li><li><code>gir restore &lt;file&gt;</code> ：对修改进行恢复，即<code>丢弃(discard)</code>这次对于工作区文件的修改。<ul><li>如果暂存区没有内容，工作区内容恢复到当前版本(HEAD指针指向的位置)。</li><li>如果有内容，恢复到暂存区的内容。</li></ul></li></ol></li><li><p>执行<code>git add</code>操作，查看工作区状态</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629213057698.png" alt="image-20230629213057698" style="zoom:50%;" /></p><p>拓展操作:</p><ol><li><code>git restore --staged &lt;file&gt;</code>：将<code>git add &lt;file&gt;</code>放在暂存区的内容恢复到当前<code>HEAD</code>指向的版本。</li><li><code>git diff &lt;file&gt;</code>：将当前版本的文件内容与暂存区的内容对比，如果暂存区为空，与当前<code>HEAD</code>指向的版本对比.</li></ol><p>​        <img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629214114827.png" alt="image-20230629214114827" style="zoom:50%;" /></p></li><li><p>再次进行修改，追加<code>333</code>，然后进行持久化操作。(<code>third commit</code>)</p><ol><li><p><code>git log --pretty=oneline</code>：查看从根节点到当前版本的版本树, 顺序自底向上，<code>HEAD</code>指向当前分支所在的版本</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629215008589.png" alt="image-20230629215008589" style="zoom:50%;" /></p></li><li><p><code>git reset --hard HEAD^</code> 或 <code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><ul><li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li><li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li><li><code>git reset --hard 版本号1</code>：回滚到某一特定版本</li></ul></li><li><p><code>git reflog</code>：查看<code>HEAD</code>指针走过的所有版本。</p><p>跳到第二个版本，又跳回第三个版本</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629215946065.png" alt="image-20230629215946065" style="zoom:50%;" /></p></li></ol></li><li><p>新添加两个文件，<code>a.txt</code>, <code>b.txt</code>, 进行提交，作为第四个版本(<code>new add two txt</code>)</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629225325457.png" alt="image-20230629225325457" style="zoom:50%;" /></p><ol><li><p>对<code>a.txt</code>进行修改</p></li><li><p>提交到暂存区后，使用<code>git rm --cache a.txt</code> 取消对a.txt文件的追踪(<code>放弃对文件的管理</code>)，类似于工作区中刚创建该文件还没有add到暂存区），工作区没有任何变化。与<code>git restore --staged a.txt</code>的差别是：</p><ul><li>后者是使文件恢复到当前<code>HEAD</code>所指向的版本的文件内容，中间修改了文件，再次提交到暂存区内容不会发生变化。</li><li>前者是放弃对文件的追踪，可以通过<code>git add</code>恢复，不过如果中间修改了内容，再次提交到暂存区内容会发生变化。</li></ul><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629232535173.png" alt="image-20230629232535173" style="zoom:50%;" /></p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629234640637.png" alt="image-20230629234640637" style="zoom:50%;" /></p><p>版本：<code>rm a from cache</code></p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629234742060.png" alt="image-20230629234742060"></p></li></ol></li></ul></li></ol><pre><code> ### 版本树 ![image-20230629235130782](D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230629235130782.png)</code></pre><h2 id="推送到github"><a href="#推送到github" class="headerlink" title="推送到github"></a>推送到github</h2><ol><li><p>先在github创建一个与文件夹(yyyy)相同的仓库</p></li><li><p>执行<code>git remote add origin git@github.com:xxxxx/yyyy.git</code> 将本地的推送到远端</p></li><li><p><code>git clone git@github.com:xxxxx/yyyy.git</code>将远端的代码克隆到本地。</p></li><li><p><code>git checkout -b dev</code>创建并切换到dev分支</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630003101217.png" alt="image-20230630003101217" style="zoom:50%;" /></p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630003115697.png" alt="image-20230630003115697" style="zoom:50%;" /></p></li><li><p>修改readme.txt并持久化(<code>add 777</code>)</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630003153135.png" alt="image-20230630003153135" style="zoom:50%;" /></p></li><li><p>切换到<code>master</code>分支，将<code>dev</code>分支的内容合并到<code>master</code>分支</p></li></ol><p>​    <img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630003234807.png" alt="image-20230630003234807" style="zoom:50%;" /></p><ol><li>新建<code>dev</code>分支，修改readme.txt并持久化(<code>add 888</code>)</li></ol><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630004903874.png" alt="image-20230630004903874" style="zoom:50%;" /></p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005040229.png" alt="image-20230630005040229" style="zoom:50%;" /></p><ol><li><p>切换到<code>master</code>分支，修改readme.txt并持久化(<code>add 999</code>)</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005115395.png" alt="image-20230630005115395" style="zoom:50%;" /></p></li></ol><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005100804.png" alt="image-20230630005100804" style="zoom:50%;" /></p><ol><li>在<code>master</code>分支合并<code>dev</code>分支，出现冲突，处理完成后，在此进行持久化(<code>solve merge problem</code>)</li></ol><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005252849.png" alt="image-20230630005252849" style="zoom:50%;" /></p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005304312.png" alt="image-20230630005304312" style="zoom:50%;" /></p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005323661.png" alt="image-20230630005323661" style="zoom:50%;" /></p><p>查看版本树：</p><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630005402167.png" alt="image-20230630005402167" style="zoom:50%;" /></p><h3 id="版本树"><a href="#版本树" class="headerlink" title="版本树"></a>版本树</h3><p><img src="D:\MyBlog\source\_posts\2023-06-29-git-study.assets\image-20230630011555500.png" alt="image-20230630011555500" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge_Sort</title>
      <link href="/2023/06/27/Merge-Sort/"/>
      <url>/2023/06/27/Merge-Sort/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>归并排序（<a href="https://en.wikipedia.org/wiki/Merge_sort">merge sort</a>）是高效的基于比较的稳定排序算法</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>基于分治思想将数组分为两个部分，使这两部分有序后，再进行合并，使最终序列有序，即不断对分开的序列进行递归处理，使序列的每一部分都有序，然后进行合并，得到最终的有序序列。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l, mid), <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) temp[k ++] = q[i ++];</span><br><span class="line">        <span class="keyword">else</span> temp[k ++] = q[j ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) temp[k ++] = q[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) temp[k ++] = q[j ++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++,j++) q[i] = temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展知识：<code>merge(start1, end1, start2, end2, arr, cmp)</code> 函数</p><p>将两个升序的序列<code>a</code>,<code>b</code>按照<code>a</code>序列的区间 $[start1, end1)$内的数 和<code>b</code>序列的区间 $[start2, end2)$ 的数进行合并 ，并存储到<code>arr</code>中。</p><p>优化后的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l, mid), <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">merge</span>(q + l, q + mid + <span class="number">1</span>, q + j, q + r + <span class="number">1</span>, temp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++,j++) q[i] = temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展题型"><a href="#拓展题型" class="headerlink" title="拓展题型"></a>拓展题型</h2><h3 id="1-求逆序对的数量"><a href="#1-求逆序对的数量" class="headerlink" title="1.求逆序对的数量"></a>1.求逆序对的数量</h3><p><a href="https://www.acwing.com/problem/content/790/">题目信息</a></p><p>关键：当数组有序时，数组中的逆序对为0，所以在归并排序中，每次和并数组两部分时都会减少逆序对的数量，同样也可以统计逆序对的数量，设左半部分的数为 <code>a[i]</code>, 右半部分的为 <code>a[j]</code> 如果 <code>a[i] &gt; a[j]</code>, 则左半部分从i后的所有数都大于<code>a[j]</code>, 这时便可以统计逆序对的数量了，直接全部计算即可，即 <code>m - i + 1</code>(m为进行分治的部分)，因为数组有序时，逆序对的数量为0，这样才不会少统计。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l, m), <span class="built_in">merge_sort</span>(m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = m + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[j]) t[k ++] = a[j ++], ans += m - i + <span class="number">1</span>; <span class="comment">// 统计数目</span></span><br><span class="line">        <span class="keyword">else</span> t[k ++] = a[i ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m) t[k ++] = a[i ++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) t[k ++] = a[j ++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) a[i] = t[j]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quick_Sort</title>
      <link href="/2023/06/27/Quick-Sort/"/>
      <url>/2023/06/27/Quick-Sort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>快速排序（英语：Quicksort），又称分区交换排序（英语：partition-exchange sort），简称「快排」，是一种被广泛运用的排序算法。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>快速排序的工作原理是通过分治的方式对数组进行排序</p><p> 快速排序基本分为三个过程：</p><ol><li>将数组划分成两个部分 (两部分保持相对大小关系)</li><li>对两部分进行递归求解</li><li>无需合并，此时数组已经是有序</li></ol><p>性质：保证在一个<code>x</code>值的约束下, 数组分为两部分，一部分总是小于<code>x</code>，另一部分大于<code>x</code>, 所以在进行快速排序的过程中，数组总是分成两部分，且两部分保持相对大小。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = q[(l + r) &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展题型"><a href="#扩展题型" class="headerlink" title="扩展题型"></a>扩展题型</h2><h3 id="1-第k个数"><a href="#1-第k个数" class="headerlink" title="1.第k个数"></a>1.第k个数</h3><p> <a href="https://www.acwing.com/problem/content/788/">题目信息</a> </p><p>相关点：因为快速排序能够保证数组有两部分能保持相对大小，所以求第<code>k</code>个数，我们可以根据其下标<code>k-1</code>快速选择结果所存在的数组部分进行递归，从而快速得到结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="type">int</span> x = q[(l + r) &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k - <span class="number">1</span> &lt;= j) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(l, j);   <span class="comment">//下标小于等于j，代表数值小于等于x</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展信息：<code>nth_element(first, nth, last, cmp)</code> 函数用法</p><p>该函数会将某个序列按照默认的升序排序，从该序列中找到第 n 小的元素 K，并将 K 移动到序列中第 n 的位置处。不仅如此，整个序列经过 nth_element() 函数处理后，所有位于 K 之前的元素都比 K 小，所有位于 K 之后的元素都比 K 大。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS</title>
      <link href="/2023/06/16/BFS/"/>
      <url>/2023/06/16/BFS/</url>
      
        <content type="html"><![CDATA[<h4 id="1-走迷宫"><a href="#1-走迷宫" class="headerlink" title="1.走迷宫"></a>1.走迷宫</h4><p>给定一个 <strong>n×m</strong> 的二维整数数组，用来表示一个迷宫，数组中只包含 <strong>0</strong> 或 <strong>1</strong>，其中 <strong>0</strong> 表示可以走的路，<strong>1</strong> 表示不可通过的墙壁。</p><p>最初，有一个人位于左上角 <strong>(1,1)</strong> 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p><p>请问，该人从左上角移动至右下角 <strong>(n,m)</strong>处，至少需要移动多少次。</p><p>数据保证 <strong>(1,1)</strong> 处和 <strong>(n,m)</strong> 处的数字为 <strong>0</strong>，且一定至少存在一条通路。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <strong>n</strong> 和 <strong>m</strong>。</p><p>接下来 <strong>n </strong>行，每行包含 <strong>m</strong> 个整数（<strong>0 或 1</strong>），表示完整的二维数组迷宫。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><strong>1  ≤  n,m  ≤  100</strong></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">0 1 0 0 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 1 0</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N], d[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = p.first + dx[i], ny = p.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= m &amp;&amp; g[nx][ny] == <span class="number">0</span> &amp;&amp; d[nx][ny] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[nx][ny] = d[p.first][p.second] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-有向图的拓扑序列"><a href="#2-有向图的拓扑序列" class="headerlink" title="2.有向图的拓扑序列"></a>2.有向图的拓扑序列</h4><p>给定一个 <strong>n</strong> 个点 <strong>m</strong> 条边的有向图，点的编号是 <strong>1</strong> 到 <strong>n</strong>，图中可能存在重边和自环。</p><p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 <strong>−1</strong>。</p><p>若一个由图中所有点构成的序列 <strong>A</strong> 满足：对于图中的每条边 <strong>(x,y)</strong>，<strong>x</strong> 在 <strong>A</strong> 中都出现在 <strong>y</strong> 之前，则称 <strong>A</strong> 是该图的一个拓扑序列。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 <strong>n</strong> 和 <strong>m</strong>。</p><p>接下来 <strong>m</strong> 行，每行包含两个整数 <strong>x</strong> 和 <strong>y</strong>，表示存在一条从点 x 到点 y 的有向边 <strong>(x,y)</strong>。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出 <strong>-1</strong>。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><script type="math/tex; mode=display">1≤n,m≤  10^5</script><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &lt;ctrin</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> q[N],d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) <span class="keyword">if</span>(!d[i]) q[++ tt] = i;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = q[hh ++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            d[j] --;</span><br><span class="line">            <span class="keyword">if</span>(!d[j]) q[++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        d[b] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">toposort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test1</title>
      <link href="/2023/06/15/test1/"/>
      <url>/2023/06/15/test1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你好&quot;</span> &lt;&lt; endl</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/15/hello-world/"/>
      <url>/2023/06/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
